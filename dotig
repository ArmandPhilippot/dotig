#!/bin/bash
#
# Dotig
# A dotfiles manager to quickly setup your machine & synchronize your dotfiles
# with Git.
#
# Requirements: Git, GNU/Linux, GNU Coreutils and curl.
# Tested with: Manjaro 21, Debian 10, Ubuntu 20 and Fedora 34.
# Author: Armand Philippot <https://www.armandphilippot.com/>
# URL: https://github.com/ArmandPhilippot/dotig

###############################################################################
#
# The MIT License (MIT)

# Copyright (c) 2021 Armand Philippot

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
###############################################################################

set -e

###############################################################################
# Global variables
###############################################################################
# Dotig info
DOTIG_COMMANDS=("add" "update" "commit" "push" "pull" "submodule" "rm" "status")
DOTIG_LOGO=$(
  cat <<-EOF
#######################################
##      ____        _   _            ##
##     |  _ \  ___ | |_(_) __ _      ##
##     | | | |/ _ \| __| |/ _  |     ##
##     | |_| | (_) | |_| | (_| |     ##
##     |____/ \___/ \__|_|\__, |     ##
##                        |___/      ##
##                                   ##
#######################################
EOF
)
DOTIG_PATH=""
DOTIG_VERSION="1.0.0"

# Colors
_color_choice=$(printf '\e[34m')
_color_error=$(printf '\e[31m')
_color_output=$(printf '\e[35m')
_color_reset=$(printf '\e[0m')
_color_success=$(printf '\e[32m')
_color_warning=$(printf '\e[33m')

# Parameters
_disable_menu="false"
_show_repo_status="true"
_verbose="false"

###############################################################################
# Helpers
# Various helpers used across the script in different locations.
###############################################################################

# Print Dotig logo
print_logo() {
  printf "%s\n\n" "$DOTIG_LOGO"
}

# Return the absolute path.
# Argument 1: a path to convert. Also used to store the absolute path.
get_absolute_path() {
  [ $# -ne 1 ] && error_unexpected

  local -n _file=$1
  local _absolute_path

  case $_file in
  /*) _absolute_path=$_file ;;
  \~/*) _absolute_path="$HOME/${_file:2}" ;;
  ./*) _absolute_path="$(pwd)/${_file:2}" ;;
  *) _absolute_path="$(pwd)/$_file" ;;
  esac

  eval "$1=$_absolute_path"
}

# Prompt user to define an existing directory path.
# Return the entered path.
set_path() {
  local _path
  printf "Set the path: " >&2
  read -r -e _path
  get_absolute_path _path

  while [ ! -d "$_path" ]; do
    printf "%sError:%s %s is not a directory.\n" "$_color_error" "$_color_reset" "${_color_output}${_path}${_color_reset}"
    printf "Please enter a valid path: "
    read -r -e _path
    get_absolute_path _path
  done

  case $_path in
    */) : ;;
    *) _path="${_path}/"
  esac

  eval "$1=$_path"
}

# Ask user if the provided path is correct, if not define new path.
# Argument 1: the path to test. Also used to store the path.
# Return the path (the new one or preserve the previous one).
is_correct_path() {
  [ $# -ne 1 ] && error_unexpected

  local _validation
  local -n _valid_path=$1

  while true; do
    printf "Is %s%s%s correct? %s[y/n]%s " "$_color_output" "$_valid_path" "$_color_reset" "$_color_choice" "$_color_reset"
    read -r _validation
    case $_validation in
    [yY])
      break
      ;;
    [nN])
      set_path _valid_path
      ;;
    *) printf "%sError:%s please enter %s[y]%ses or %s[n]%so." "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" ;;
    esac
  done
}

# Check if a file is in $HOME.
# Argument 1: the file to test
is_file_in_home() {
  [ $# -eq 0 ] && error_unexpected

  local _file=$1

  case $_file in
    "$HOME"*) return 0 ;;
    *) return 1
  esac
}

# Check if a file is in $DOTIG_PATH.
# Argument 1: the file to test
is_file_in_backup_path() {
  [ $# -eq 0 ] && error_unexpected

  local _file=$1

  case $_file in
    "$DOTIG_PATH"*) return 0 ;;
    *) return 1
  esac
}

is_verbose() {
  [ "$_verbose" = "true" ]
}

###############################################################################
# Error Helpers
# Functions to handle the various error messages.
###############################################################################

# Clean up temporary files then exit.
cleanup() {
  is_verbose && printf "\n\nDeleting temporary files...\n"
  rm -f "$_tmp"
  if is_verbose; then
    printf "%sSuccess:%s Temporary files deleted.\n" "$_color_success" "$_color_reset"
    printf "Exit.\n"
  fi
  exit
}

# Display an error in case of an unplanned scenario then exit.
error_unexpected() {
  printf "%sAn unexpected error occurred.%s Exit.\n" "$_color_error" "$_color_reset"
  cleanup
  exit 1
}

# Display an error in case of invalid usage then exist.
invalid_usage() {
  printf "%sError:%s invalid usage.\n" "$_color_error" "$_color_reset"
  printf "Use \`dotig --help\` or \`dotig -h\` to display all accepted commands and options.\n"
  exit 1
}

# Display an error if $DOTFILES (backup path) is not defined then exit.
error_backup_path() {
  printf "%sError:%s \$DOTFILES must be set to use Dotig command line interface.\n" "$_color_error" "$_color_reset"
  printf "See CONFIGURATION in \`dotig --help\` or \`dotig -h\`.\n"
  exit 1
}

# Execute cleanup function if these signals are caught.
trap cleanup SIGHUP SIGINT SIGQUIT SIGTERM

###############################################################################
# Git Helpers
# Git specific helpers used in different locations across the script.
###############################################################################

# Return the branch name on which the working tree is on.
get_current_branch() {
  git -C "$DOTIG_PATH" symbolic-ref --quiet --short HEAD
}

# Return the name of the default/main upstream branch.
get_upstream_branch() {
  local _git_branch
  _git_branch=$(get_current_branch)
  git -C "$DOTIG_PATH" config branch."$_git_branch".remote > /dev/null 2>&1
}

# Return a list of existing Git remotes.
get_existing_remotes() {
  git -C "$DOTIG_PATH" remote
}

# Download objects and refs from remote.
fetch_remote() {
  git -C "$DOTIG_PATH" fetch
}

# Return the object name of the current commit on the working tree.
get_local_commit() {
  git -C "$DOTIG_PATH" rev-parse --verify -q HEAD
}

# Return the object name of the last commit on the remote.
get_remote_commit() {
  git -C "$DOTIG_PATH" rev-parse --verify -q FETCH_HEAD
}

# Return a good common ancestor if the working tree has at least one commit.
get_common_ancestor() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" ] &&  git -C "$DOTIG_PATH" merge-base HEAD "$_remote_commit"
}

# Check if the current commit and the last commit on the remote are the same.
is_repo_up_to_date() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" = "$_remote_commit" ]
}

# Check if the remote is ahead the working tree.
is_pull_needed() {
  local _local_commit=$1
  local _common_ancestor=$2

  [ "$_local_commit" = "$_common_ancestor" ]
}

# Check if the remote is behind the working tree.
is_push_needed() {
  local _remote_commit=$1
  local _common_ancestor=$2

  [ "$_remote_commit" = "$_common_ancestor" ]
}

# Return the number of changed files (modified, deleted...) on the working tree.
get_dirty_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | wc -l
}

# Check if the working tree has changed files.
is_repo_dirty() {
  local _dirty_files_count
  _dirty_files_count=$(get_dirty_files_count)

  [ "$_dirty_files_count" -ne 0 ]
}

# Return the number of untracked files.
get_untracked_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^??"
}

# Return the number of staged files.
get_staged_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^[A|M]"
}

# Return the number of deleted files.
get_deleted_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^.D"
}

# Return the number of renamed files.
get_renamed_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^R"
}

# Return the number of modified files.
get_modified_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^.M"
}

# Return the number of unmerged files.
get_unmerged_files_count() {
  git -C "$DOTIG_PATH" ls-files --unmerged | wc -l
}

# Return the number of stash.
get_stashed_count() {
  git -C "$DOTIG_PATH" stash list | wc -l
}

# Return the list of unpushed commits.
get_unpushed_commits() {
  local _current_branch
  local _upstream_branch

  _current_branch=$(get_current_branch)
  _upstream_branch=$(get_upstream_branch)

  [ "$_local_commit" ] &&  git -C "$DOTIG_PATH" log --oneline "$_upstream_branch"/"$_current_branch"..HEAD
}

# Check if the repo has Git submodules.
has_submodules() {
  local _tmp
  local _submodules

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  git -C "$DOTIG_PATH" submodule status > "$_tmp"

  while IFS='' read -r line; do _submodules+=("$line"); done < "$_tmp"

  rm "$_tmp"

  [ "${#_submodules[@]}" -gt 0 ]
}

# Update all the Git submodules.
update_submodules() {
  git -C "$DOTIG_PATH" submodule update --init --recursive
}

# Return a list of Git submodule paths.
get_submodules_path() {
  # shellcheck disable=SC2016
  git -C "$DOTIG_PATH" submodule -q foreach 'printf ${sm_path}"\n"'
}

# Check if the dotfiles backup directory is a Git repository.
is_git_repo() {
  git -C "$DOTIG_PATH" rev-parse --git-dir > /dev/null 2>&1
}

###############################################################################
# XDG Specification
# Use XDG paths to handle dotfiles and symlinks.
###############################################################################

# Check if XDG path are set, if not set them.
set_xdg_paths() {
  if is_linux; then
    XDG_BIN_HOME=${XDG_BIN_HOME:-$HOME/.local/bin}
    XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
    XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
    XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
    XDG_LIB_HOME=${XDG_LIB_HOME:-$HOME/.local/lib}
    XDG_STATE_HOME=${XDG_STATE_HOME:-$HOME/.local/state}
  else
    printf "%sError:%s Only Linux is supported.\n" "$_color_error" "$_color_reset"
    exit 2
  fi
}

###############################################################################
# Safety Checks
# Do not execute Dotig if operating system is not supported or if Git is not
# installed.
###############################################################################

# Check if the current OS is GNU/Linux.
is_linux() {
  [ "$OSTYPE" = "linux-gnu" ]
}

# Check for supported OS/distribution.
check_os() {
  is_verbose && printf "Identifying the operating system...\n"

  if is_linux; then
    if is_verbose; then
      printf "%sSuccess:%s Linux is supported.\n" "$_color_success" "$_color_reset"
    fi
  else
    printf "%sError:%s Linux is the only supported operating system.\n" "$_color_error" "$_color_reset"
    printf "Exit.\n"
    exit 1
  fi
}

# Check if Git is installed.
is_git_installed() {
  [ -x "$(command -v git)" ]
}

# Check if curl is installed.
is_curl_installed() {
  [ -x "$(command -v curl)" ]
}

# Check if the commands required by the script are available.
check_commands() {
  is_verbose && printf "Checking installed programs...\n"

  if is_git_installed; then
    if is_verbose; then
      printf "%sSuccess:%s Git is installed.\n" "$_color_success" "$_color_reset"
    fi
  else
    printf "%sError:%s Dotig needs Git to function properly.\n" "$_color_error" "$_color_reset"
    printf "Please install it before using this program.\n"
    printf "Exit.\n"
    exit 1
  fi

  if is_curl_installed; then
    if is_verbose; then
      printf "%sSuccess:%s curl is installed.\n" "$_color_success" "$_color_reset"
    fi
  else
    printf "%sWarning:%s curl is needed to check for Dotig update. Please install it if you want to use this feature.\n" "$_color_warning" "$_color_reset"
  fi
}

# Check if all the requirements are filled.
check_requirements() {
  is_verbose && printf "Checking requirements...\n"
  check_os
  check_commands
  if is_verbose; then
    printf "%sSuccess:%s Requirements checked!\n" "$_color_success" "$_color_reset"
    printf "Let's continue.\n\n"
  fi
}

###############################################################################
# Repo configuration
# Check if $DOTFILES is defined and if it is a repo. If not, set both.
###############################################################################

# Check if $DOTFILES is set and contains the correct backup path, if not set it.
# Require 1 argument to store the path.
# Return the path to use.
check_backup_path() {
  local _backup_path

  is_verbose && printf "For conveniance, Dotig uses a \$DOTFILES variable to determine the dotfiles backup path. If it is not set, you may want to declare it for future use.\n\n"
  printf "Checking if a \$DOTFILES variable is set...\n"

  if [ ! "$DOTFILES" ]; then
    printf "%sWarning:%s The \$DOTFILES variable is not set.\n" "$_color_warning" "$_color_reset"
    set_path _backup_path
    is_correct_path _backup_path
  elif [ ! -d "$DOTFILES" ]; then
    printf "%sWarning:%s The \$DOTFILES variable does not seem to match a directory.\n" "$_color_warning" "$_color_reset"
    set_path _backup_path
    is_correct_path _backup_path
  else
    is_verbose && printf "%sSuccess:%s Found \$DOTFILES variable.\n" "$_color_success" "$_color_reset"
    _backup_path=$DOTFILES
    get_absolute_path _backup_path

    case $_backup_path in
      */) : ;;
      *) _backup_path="${_backup_path}/"
    esac

    is_correct_path _backup_path
  fi

  eval "$1=$_backup_path"
}

# Check if the provided remote name exists.
# Argument 1: the remote to test.
# Argument 2: a list of existing remotes.
is_valid_remote_name() {
  [ $# -ne 2 ] && error_unexpected

  case $2 in
    *"$1"* ) return 0 ;;
    *) return 1 ;;
  esac
}

# Ask the remote name when multiple remotes exist.
# Require 1 argument to store the remote name.
# Return the remote name.
ask_remote_name() {
  local _git_remotes
  local _current_branch
  local _choice

  _git_remotes=$(get_existing_remotes)
  _current_branch=$(get_current_branch)

  printf "%sWarning:%s Your repo contains multiple remotes:\n" "$_color_warning" "$_color_reset"
  printf "%s\n" "$_git_remotes"
  printf "Choose the remote to use for %s: " "${_color_output}${_current_branch}${_color_reset}"
  read -r _choice

  while ! is_valid_remote_name "$_choice" "$_git_remotes"; do
    printf "\n%sError:%s Remote name invalid.\n" "$_color_error" "$_color_reset"
    printf "Use one of:\n"
    printf "%s\n" "${_color_choice}${_git_remotes}${_color_reset}"
    printf "Enter a valid remote name: "
    read -r _choice
  done

  printf "\n"

  eval "$1=$_choice"
}

# Define the upstream branch and update the local repo.
set_upstream_branch() {
  local _git_remotes
  local _remote_name
  local _remote_branch

  _git_remotes=$(get_existing_remotes)

  if [ "$(printf "%s\n" "$_git_remotes" | wc -l)" -gt 1 ]; then
    ask_remote_name _remote_name
  else
    _remote_name=$_git_remotes
  fi

  _remote_branch=$(git -C "$DOTIG_PATH" ls-remote --symref origin HEAD | head -1 | sed 's@ref: refs/heads/@@' | cut -f1)

  git -C "$DOTIG_PATH" fetch "$_remote_name"
  git -C "$DOTIG_PATH" checkout -t "$_remote_name"/"$_remote_branch"

  if is_verbose; then
    printf "%sSuccess:%s Upstream set.\n" "$_color_success" "$_color_reset"
  fi
}

# Check if the upstream branch is set, if not define it.
check_upstream() {
  if ! get_upstream_branch; then
    set_upstream_branch
  fi
}

# Check if the provided remote URL is a supported URL.
# Argument 1: the URL to test.
is_valid_remote_url() {
  [ $# -ne 1 ] && error_unexpected

  local _remote_url=$1

  case $_remote_url in
    "https"* | "git@"*) return 0 ;;
    *) return 1 ;;
  esac
}

# Check if the provided URL is an existing remote.
# Argument 1: the URL to test.
is_existing_remote() {
  local _remote=$1

  git ls-remote "$_remote" > /dev/null 2>&1
}

# Check if the provided remote URL is a remote repository.
# Argument 1: the URL to test.
is_valid_remote() {
  [ $# -ne 1 ] && error_unexpected

  local -n _valid_remote=$1

  printf "\nChecking if this URL exists. Your SSH passphrase can be requested.\n"

  if is_valid_remote_url "$_valid_remote"; then
    if ! is_existing_remote "$_valid_remote"; then
      printf "%sError:%s This remote URL does not exist.\n" "$_color_error" "$_color_reset"
      return 1
    fi

    return 0
  else
    printf "%sError:%s The remote URL is not valid. URL must starts with 'https' or 'git@'.\n" "$_color_error" "$_color_reset"

    return 1
  fi
}

# Define the remote repository.
set_remote() {
  local _remote

  printf "Dotig needs to know your remote to perform some actions (status, push, pull).\n"
  printf "Please enter your remote address: "
  read -r _remote

  while ! is_valid_remote _remote; do
    printf "Please enter a valid remote address: "
    read -r _remote
  done

  git -C "$DOTIG_PATH" remote add origin "$_remote"

  if is_verbose; then
    printf "%sSuccess:%s Remote set.\n" "$_color_success" "$_color_reset"
  fi
}

# Check if the remote repository is set, if not define it.
check_remote() {
  if ! git -C "$DOTIG_PATH" config --get-regexp '^remote\.' > /dev/null 2>&1; then
    if is_verbose; then
      printf "\n%sWarning:%s Dotig is a Git repository but the remote is not set.\n\n" "$_color_warning" "$_color_reset"
    fi
    set_remote
  fi
}

# Initialize the Git submodules.
init_submodules() {
  if has_submodules; then
    if is_verbose; then
      printf "Init submodules...\n"
    fi
    update_submodules
    if is_verbose; then
      printf "%sSuccess:%s All submodules have been initialized and updated.\n" "$_color_success" "$_color_reset"
    fi
  fi
}

# Initialize a new Git repository with remote, upstream and submodules.
init_git() {
  git -C "$DOTIG_PATH" init
  printf "\n"
  set_remote
  set_upstream_branch
  init_submodules
}

# Check if the Git repository is ready, if not complete the configuration.
check_git_configuration() {
  local _choice

  is_verbose && printf "\nChecking if Git is configured...\n"

  if ! is_git_repo; then
    printf "\n%sWarning:%s Your dotfiles directory is not a Git repository.\n" "$_color_warning" "$_color_reset"
    while true; do
      printf "Do you want to configure it? %s[y/n]%s " "$_color_choice" "$_color_reset"
      read -r _choice
      case $_choice in
        [yY])
          init_git
          return 0
          ;;
        [nN])
          printf "\n%sWarning:%s Dotig needs a Git repository to properly function. Please configure it manually before using this program.\n" "$_color_warning" "$_color_reset"
          printf "Exit.\n"
          exit
          ;;
        *) printf "%sError:%s Enter %s[y]%ses or %s[n]%sno" "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" ;;
      esac
    done
  else
    check_remote
    check_upstream
  fi
}

# Check if the dotfiles path is set and if it is a Git repository, if not
# configure it.
is_backup_repo_ready() {
  check_backup_path DOTIG_PATH
  check_git_configuration
  printf "%sSuccess:%s Your dotfiles repo is ready.\n" "$_color_success" "$_color_reset"
}

###############################################################################
# Repo Status
# Call git to obtain some info about the repo status and display these info.
###############################################################################

# Display the number of affected files foreach type of change.
get_expanded_status() {
  local _untracked_files_count
  local _staged_files_count
  local _deleted_files_count
  local _renamed_files_count
  local _modified_files_count
  local _unmerged_files_count
  local _stashed_files_count
  local _expanded_status

  _untracked_files_count=$(get_untracked_files_count) || true
  _staged_files_count=$(get_staged_files_count) || true
  _deleted_files_count=$(get_deleted_files_count) || true
  _renamed_files_count=$(get_renamed_files_count) || true
  _modified_files_count=$(get_modified_files_count) || true
  _unmerged_files_count=$(get_unmerged_files_count) || true
  _stashed_files_count=$(get_stashed_count) || true

  _expanded_status="You have:\n"
  [ "$_untracked_files_count" -gt 0 ] && _expanded_status+="* $_untracked_files_count untracked files\n"
  [ "$_staged_files_count" -gt 0 ] && _expanded_status+="* $_staged_files_count staged files\n"
  [ "$_deleted_files_count" -gt 0 ] && _expanded_status+="* $_deleted_files_count deleted files\n"
  [ "$_renamed_files_count" -gt 0 ] && _expanded_status+="* $_renamed_files_count renamed files"
  [ "$_modified_files_count" -gt 0 ] && _expanded_status+="* $_modified_files_count modified files\n"
  [ "$_unmerged_files_count" -gt 0 ] && _expanded_status+="* $_unmerged_files_count unmerged files\n"
  [ "$_stashed_files_count" -gt 0 ] && _expanded_status+="* $_stashed_files_count stashed files\n"

  printf "%b" "$_expanded_status"
}

# Display the repository status.
get_repo_status() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  printf "\nChecking status...\n"
  printf "Your SSH passphrase can be requested.\n"
  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if is_repo_up_to_date "$_local_commit" "$_remote_commit"; then
    printf "Status: %sup-to-date!%s\n" "$_color_success" "$_color_reset"
  else
    is_pull_needed "$_local_commit" "$_common_ancestor" && printf "Status: %spull needed!%s\n" "$_color_warning" "$_color_reset"
    is_push_needed "$_remote_commit" "$_common_ancestor" && printf "Status: %spush needed!%s\n" "$_color_warning" "$_color_reset"
  fi

  if is_repo_dirty; then
    printf "Status: %sdirty repo!%s\n" "$_color_warning" "$_color_reset"
    get_expanded_status
  else
    printf "Status: %sclean repo!%s\n" "$_color_success" "$_color_reset"
  fi
}

###############################################################################
# Dotig options
# Allow user to check current version of Dotig and to check for updates.
###############################################################################

# Display the version number of Dotig.
print_dotig_version() {
  printf "\nYour Dotig version is: %s\n" "$DOTIG_VERSION"
  return_menu
}

# Get a JSON object corresponding to the latest release.
get_latest_release() {
  curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/ArmandPhilippot/dotig/releases/latest
}

# Check if a new release exist by comparing the current version and the version
# of the latest release. If a new version exists, display a link to download it.
check_dotig_updates() {
  local _latest_release
  local _tag_name
  local _new_version
  local _download_zip
  local _download_link
  local _not_found

  if ! is_curl_installed; then
    printf "\n%sError:%s curl is needed to check for Dotig update. Please install it.\n" "$_color_error" "$_color_reset"
    return_menu
  fi

  _latest_release=$(get_latest_release)
  _not_found=$(printf "%s" "$_latest_release" | { grep -Po '"message": "Not Found"' || true; })

  if [ "$_not_found" ] ; then
    printf "\n%sError:%s could not find any release...\n" "$_color_error" "$_color_reset"
  else
    _tag_name=$(printf "%s" "$_latest_release" | grep -Po '"tag_name":.*?[^\\]",')
    _new_version=$(printf "%s" "$_tag_name" | grep -Po '(?=v).*(?=",)' | sed 's/^v//')

    if [ "$_new_version" = "$DOTIG_VERSION" ]; then
      printf "\n%sSuccess:%s Your Dotig version is up to date!\n" "$_color_success" "$_color_reset"
    else
      _download_zip=$(printf "%s" "$_latest_release" | grep -Po '"zipball_url":.*?[^\\]",')
      _download_link=$(printf "%s" "$_download_zip" | grep -Po 'http.*(?=",)')

      printf "\n%sWarning:%s Your Dotig version is outdated!\n" "$_color_warning" "$_color_reset"
      printf "A new version is available: %s\n" "$_new_version"
      printf "You can download it here: %s\n" "$_download_link"
    fi
  fi

  return_menu
}

###############################################################################
# Symlinking options
# Main feature of Dotig: handle backup of dotfiles and symlinking.
###############################################################################

# Display the diff between two files.
# Argument 1: the file residing in $HOME.
# Argument 2: the file residing in $DOTFILES.
print_diff() {
  local _home_dotfile=$1
  local _backup_dotfile=$2
  local _filename
  local _column_width
  local _padding
  local _padding_lenght
  local _divider

  [ ! $COLUMNS ] && COLUMNS=$(stty size | awk '{print $2}')
  _column_width=$(("$COLUMNS" / 2))
  _filename=$(basename "$_home_dotfile")
  _padding=$(printf '%*s' "$COLUMNS" "")
  _padding_lenght=$((_column_width - ${#HOME}))
  _divider=${_padding// /=}

  if diff -q "$_home_dotfile" "$_backup_dotfile" > /dev/null 2>&1; then
    printf "\nBoth files are identical.\n"
  else
    printf "\nThe two files are different. See the diff of %s:\n\n" "${_color_output}${_filename}${_color_reset}"
    printf "%s%0.${_padding_lenght}s%s\n" "$HOME" "$_padding" "$DOTIG_PATH";
    printf "%s\n" "$_divider";
    command diff --color -y --width="$COLUMNS" -t --suppress-common-lines "$_home_dotfile" "$_backup_dotfile" || [ $? -eq 1 ]
  fi
}

# Display the available choices in case of duplicate files.
print_duplicate_menu() {
  printf "%s[1]%s Show diff\n" "$_color_choice" "$_color_reset"
  printf "%s[2]%s Use %s (delete the other)\n" "$_color_choice" "$_color_reset" "${_color_output}${_home_dotfile}${_color_reset}"
  printf "%s[3]%s Use %s (delete the other)\n" "$_color_choice" "$_color_reset" "${_color_output}${_backup_dotfile}${_color_reset}"
  printf "%s[4]%s Skip this file\n" "$_color_choice" "$_color_reset"
}

# Execute the action specified by the user in case of duplication.
# Argument 1: the file residing in $HOME.
# Argument 2: the file residing in $DOTFILES.
handle_duplicate() {
  local _choice
  local _home_dotfile=$1
  local _backup_dotfile=$2

  printf "\n%sWarning:%s A file with the same name already exists.\n" "$_color_warning" "$_color_reset"

  [ -h "$_backup_dotfile" ] && printf "%sWarning:%s %s is a symlink.\n" "$_color_warning" "$_color_reset" "${_color_output}${_backup_dotfile}${_color_reset}"
  [ -h "$_home_dotfile" ] && printf "%sWarning:%s %s is a symlink.\n" "$_color_warning" "$_color_reset" "${_color_output}${_home_dotfile}${_color_reset}"

  printf "How do you want to proceed?\n"

  while true; do
    print_duplicate_menu
    printf "Your choice: "
    read -r _choice

    case $_choice in
      1)
        print_diff "$_home_dotfile" "$_backup_dotfile"
        printf "\n"
        ;;
      2)
        mv -f "$_home_dotfile" "$_backup_dotfile"
        ln -s "$_backup_dotfile" "$_home_dotfile"
        printf "\n%sSuccess:%s %s replaced with %s and symlink created.\n" "$_color_success" "$_color_reset" "${_color_output}${_backup_dotfile}${_color_reset}" "${_color_output}${_home_dotfile}${_color_reset}"
        break
        ;;
      3)
        rm "$_home_dotfile"
        ln -s "$_backup_dotfile" "$_home_dotfile"
        printf "\n%sSuccess:%s %s replaced with a symlink.\n" "$_color_success" "$_color_reset" "${_color_output}${_home_dotfile}${_color_reset}"
        break
        ;;
      4)
        printf "\n%sSkipped:%s %s\n" "$_color_warning" "$_color_reset" "$_home_dotfile"
        break
        ;;
      *) printf "%sError:%s choose between %s[1]%s, %s[2]%s, %s[3]%s or %s[4]%s.\n" "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset"
    esac
  done
}

# Move the dotfiles from $HOME to $DOTFILES and create a symlink.
# Accept 0 or more arguments. If arguments are provided, files are expected.
add_dotfiles() {
  local _dotfiles
  local _partial_dest
  local _removed_part
  local _backup_dotfile

  if [ $# -eq 0 ]; then
    printf "\nDotfiles to add: "
    read -r -e -a _dotfiles
  else
    _dotfiles=("$@")
  fi

  for _dotfile in "${_dotfiles[@]}"; do
    get_absolute_path _dotfile
    [ ! -e "$_dotfile" ] && printf "%sError:%s %s is not a file.\n" "$_color_error" "$_color_reset" "$_file" && exit 2

    case $_dotfile in
      "$XDG_BIN_HOME"*)
        _partial_dest="home/xdg_bin"
        _removed_part="$XDG_BIN_HOME"
        ;;
      "$XDG_CACHE_HOME"*)
        _partial_dest="/home/xdg_cache"
        _removed_part="$XDG_CACHE_HOME"
        ;;
      "$XDG_CONFIG_HOME"*)
        _partial_dest="/home/xdg_config"
        _removed_part="$XDG_CONFIG_HOME"
        ;;
      "$XDG_DATA_HOME"*)
        _partial_dest="/home/xdg_data"
        _removed_part="$XDG_DATA_HOME"
        ;;
      "$XDG_LIB_HOME"*)
        _partial_dest="/home/xdg_lib"
        _removed_part="$XDG_LIB_HOME"
        ;;
      "$XDG_STATE_HOME"*)
        _partial_dest="/home/xdg_state"
        _removed_part="$XDG_STATE_HOME"
        ;;
      "$HOME"*)
        _partial_dest="/home"
        _removed_part="$HOME"
        ;;
      *)
        _partial_dest=""
        _removed_part=""
        ;;
    esac

    _backup_dotfile="${DOTIG_PATH}${_partial_dest}${_dotfile#$_removed_part}"

    if [ -e "$_backup_dotfile" ]; then
      handle_duplicate "$_dotfile" "$_backup_dotfile"
    else
      is_verbose && printf "Creating path if not already present...\n"
      mkdir -p "$(dirname "$_backup_dotfile")"

      if is_file_in_home "$_dotfile"; then
        is_verbose && printf "Moving %s to %s...\n" "$_dotfile" "$_backup_dotfile"
        mv "$_dotfile" "$_backup_dotfile"
        is_verbose && printf "Symlinking %s to %s...\n" "$_backup_dotfile" "$_dotfile"
        ln -s "$_backup_dotfile" "$_dotfile"
        printf "%sSuccess:%s %s moved and symlink created.\n" "$_color_success" "$_color_reset" "$_dotfile"
      else
        is_verbose && printf "Copying %s to %s...\n" "$_dotfile" "$_backup_dotfile"
        cp "$_dotfile" "$_backup_dotfile"
        printf "%sSuccess:%s %s copied.\n" "$_color_success" "$_color_reset" "$_dotfile"
        printf "%sWarning:%s Symlink not created. %s is not in $HOME! \n" "$_color_warning" "$_color_reset" "$_dotfile"
      fi
    fi
  done

  return_menu
}

# Find all dotfiles in the backup path excluding submodules.
# Return a list of files.
get_backup_dotfiles() {
  local _find_cmd
  local _exclude_dirs=()
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_submodules_path > "$_tmp"

  while IFS='' read -r line; do _exclude_dirs+=("$line"); done < "$_tmp"

  rm "$_tmp"
  _exclude_dirs+=('.git')

  _find_cmd=( find "$DOTIG_PATH" -mindepth 2 \( -type f -o -type l \) )

  for _exclude_dir in "${_exclude_dirs[@]}"; do
    _find_cmd+=( -not \( -path "$DOTIG_PATH${_exclude_dir}/*" -prune \) )
  done
  _find_cmd+=( -print )

  "${_find_cmd[@]}"
}

# Handle existing symlink: check if the symlink target is the expected one or
# ask user which action to perform.
# Argument 1: the file (or symlink) residing in the backup path.
# Argument 2: the symlink residing in $HOME.
handle_target_update() {
  [ $# -ne 2 ] && error_unexpected

  local _file=$1
  local _file_target
  local _symlink=$2
  local _symlink_target
  local _extra_info
  local _choice

  _symlink_target=$(readlink -f "$_symlink") || true
  [ -z "$_symlink_target" ] && _symlink_target="Target does not exist."

  if [ "$_symlink_target" = "$_file" ]; then
    if is_verbose; then
      printf "A symlink with the same target already exists.\n"
      printf "%sSkipped:%s %s\n" "$_color_warning" "$_color_reset" "$_file"
    fi
  else
    if [ -h "$_file" ]; then
      _extra_info=" (also a symlink)"
      _file_target=$(readlink -f "$_file") || true
      [ -z "$_file_target" ] && _file_target="Target does not exist."
    fi

    printf "\n%sWarning:%s A symlink exists but its target does not match your dotfile backup:\n" "$_color_warning" "$_color_reset"
    printf "* Symlink: %s\n" "${_color_output}${_symlink}${_color_reset}"
    printf "* Symlink target: %s\n" "${_color_output}${_symlink_target}${_color_reset}"
    printf "* Backup file%s: %s\n" "$_extra_info" "${_color_output}${_file}${_color_reset}"
    [ -h "$_file" ] && printf "* Backup target: %s\n" "${_color_output}${_file_target}${_color_reset}"

    printf "How do you want to proceed?\n"
    printf "%s[1]%s Update the symlink\n" "$_color_choice" "$_color_reset"
    printf "%s[2]%s Skip this file\n" "$_color_choice" "$_color_reset"

    while true; do
      printf "Your choice: "
      read -r _choice

      case $_choice in
      1)
        is_verbose && printf "Updating symlink target...\n"
        ln -s -f "$_file" "$_symlink"
        printf "%sSuccess:%s %s updated.\n" "$_color_success" "$_color_reset" "$_symlink"
        break
        ;;
      2)
        printf "\n%sSkipped:%s %s\n" "$_color_warning" "$_color_reset" "$_file"
        break
        ;;
      *) printf "%sError:%s Enter %s[1]%s or %s[2]%s." "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" ;;
      esac
    done
  fi
}

# Find all broken symlinks in $HOME whose target is in $DOTFILES.
get_broken_symlinks() {
  find "$HOME" -type l -not \( -path "$DOTIG_PATH/*" -prune \) -ilname "$DOTIG_PATH*" ! -exec test -e {} \; -print
}

# Remove broken symlinks in $HOME whose target is in $DOTFILES.
remove_broken_symlinks() {
  local _tmp

  printf "\nChecking for broken symlinks...\n"

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_broken_symlinks > "$_tmp"

  if [ -s "$_tmp" ]; then
    while IFS= read -r file <&3; do
      rm "$file"
      is_verbose && printf "%sSuccess:%s %s removed...\n" "$_color_success" "$_color_reset" "$file"
    done 3< "$_tmp"

    printf "%sSuccess:%s All broken symlinks removed...\n" "$_color_success" "$_color_reset"
  else
    if is_verbose; then
      printf "No broken symlinks found.\n"
    fi
  fi

  rm "$_tmp"
}

# Create or update all symlinks in $HOME based on the dotfiles in the backup
# path and remove the broken symlinks.
update_symlinks() {
  local _backup_dotfile
  local _dotfile
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_backup_dotfiles > "$_tmp"

  while IFS= read -r _backup_dotfile <&3; do
    case $_backup_dotfile in
      "${DOTIG_PATH}home/xdg_bin/"*)
        _partial_dest="$XDG_BIN_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_bin"
        ;;
      "${DOTIG_PATH}home/xdg_cache/"*)
        _partial_dest="$XDG_CACHE_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_cache"
        ;;
      "${DOTIG_PATH}home/xdg_config/"*)
        _partial_dest="$XDG_CONFIG_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_config"
        ;;
      "${DOTIG_PATH}home/xdg_data/"*)
        _partial_dest="$XDG_DATA_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_data"
        ;;
      "${DOTIG_PATH}home/xdg_lib/"*)
        _partial_dest="$XDG_LIB_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_lib"
        ;;
      "${DOTIG_PATH}home/xdg_state/"*)
        _partial_dest="$XDG_STATE_HOME"
        _removed_part="${DOTIG_PATH}home/xdg_state"
        ;;
      "${DOTIG_PATH}home/"*)
        _partial_dest="$HOME"
        _removed_part="${DOTIG_PATH}home"
        ;;
      *)
        _partial_dest=""
        _removed_part="$DOTIG_PATH"
        ;;
    esac

    _dotfile="${_partial_dest}${_backup_dotfile#$_removed_part}"

    if is_file_in_home "$_dotfile"; then
      if [ -h "$_dotfile" ]; then
        handle_target_update "$_backup_dotfile" "$_dotfile"
      elif [ -f "$_dotfile" ]; then
        handle_duplicate "$_dotfile" "$_backup_dotfile"
      else
        is_verbose && printf "Creating symlink from %s to %s\n" "$_backup_dotfile" "$_dotfile"
        mkdir -p "$(dirname "$_dotfile")"
        ln -s "$_backup_dotfile" "$_dotfile"
        is_verbose && printf "%sSuccess:%s Symlink created for %s\n" "$_color_success" "$_color_reset" "$_backup_dotfile"
      fi
    else
      printf "%sWarning:%s %s is not in %s. Symlink skipped.\n" "$_color_warning" "$_color_reset" "$_dotfile" "$HOME"
    fi
  done 3< "$_tmp"

  rm "$_tmp"

  printf "\n%sSuccess:%s Done. Symlinks have been updated except those that have possibly been manually skipped or needing administrator rights.\n" "$_color_success" "$_color_reset"

  remove_broken_symlinks

  return_menu
}

# Replace the symlink with the backup file.
# Argument 1: the symlink.
# Argument 2: the backup file.
replace_symlink_with_file() {
  [ $# -ne 2 ] && error_unexpected

  local _symlink=$1
  local _backup_file=$2

  cp --remove-destination "$_backup_file" "$_symlink"
  if is_verbose; then
    printf "%sSuccess:%s %s replaced with %s\n" "$_color_success" "$_color_reset" "$_symlink" "$_backup_file"
  fi
}

# Execute the action specified by the user if the symlink target does not match
# the backup file.
# Argument 1: the symlink.
# Argument 2: the symlink target.
# Argument 3: the backup file.
handle_target_issue() {
  [ $# -ne 3 ] && error_unexpected

  local _symlink=$1
  local _target=$2
  local _backup_file=$3

  printf "\n%sWarning:%s The symlink target does not match with your backup file:\n" "$_color_warning" "$_color_reset"
  printf "* Symlink: %s\n" "${_color_output}${_symlink}${_color_reset}"
  printf "* Symlink target: %s\n" "${_color_output}${_target}${_color_reset}"
  printf "* Backup file: %s\n" "${_color_output}${_backup_file}${_color_reset}"

  printf "How do you want to proceed?\n"
  printf "%s[1]%s Replace symlink with backup file\n" "$_color_choice" "$_color_reset"
  printf "%s[2]%s Skip this symlink\n" "$_color_choice" "$_color_reset"

  while true; do
    printf "Your choice: "
    read -r _choice
    case $_choice in
    1)
      replace_symlink_with_file "$_symlink" "$_backup_file"
      break
      ;;
    2)
      is_verbose && printf "\n%sSkipped:%s %s\n" "$_color_warning" "$_color_reset" "$_symlink"
      break
      ;;
    *) printf "%sError:%s Enter %s[1]%s or %s[2]%s." "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset" ;;
    esac
  done
}

# Replace all symlinks in $HOME whose target is in $DOTFILES with the
# backup file.
remove_symlinks() {
  local _symlink
  local _symlink_target
  local _backup_dotfile
  local _tmp

  printf "\nReplacing symlinks with original files...\n"

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  find "$HOME" -type l -not \( -path "$DOTIG_PATH/*" -prune \) -ilname "$DOTIG_PATH*" -print > "$_tmp"

  while IFS= read -r _symlink <&3; do
    _symlink_target=$(readlink "$_symlink") || true

    case $_symlink_target in
      "${DOTIG_PATH}home/xdg_bin/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_bin"
        _removed_part="$XDG_BIN_HOME"
        ;;
      "${DOTIG_PATH}home/xdg_cache/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_cache"
        _removed_part="$XDG_CACHE_HOME"
        ;;
      "${DOTIG_PATH}home/xdg_config/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_config"
        _removed_part="$XDG_CONFIG_HOME"
        ;;
      "${DOTIG_PATH}home/xdg_data/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_data"
        _removed_part="$XDG_DATA_HOME"
        ;;
      "${DOTIG_PATH}home/xdg_lib/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_lib"
        _removed_part="$XDG_LIB_HOME"
        ;;
      "${DOTIG_PATH}home/xdg_state/"*)
        _partial_dest="${DOTIG_PATH}home/xdg_state"
        _removed_part="$XDG_STATE_HOME"
        ;;
      "${DOTIG_PATH}home/"*)
        _partial_dest="${DOTIG_PATH}home"
        _removed_part="$HOME"
        ;;
      *)
        _partial_dest="$DOTIG_PATH"
        _removed_part=""
        ;;
    esac

    _backup_dotfile=${_partial_dest}${_symlink#$_removed_part}

    if [ "$_backup_dotfile" = "$_symlink_target" ]; then
      replace_symlink_with_file "$_symlink" "$_backup_dotfile"
    else
      handle_target_issue "$_symlink" "$_symlink_target" "$_backup_dotfile"
    fi

  done 3< "$_tmp"

  rm "$_tmp"

  printf "\n%sSuccess:%s Done. Symlinks have been replaced except those that have possibly been manually skipped.\n" "$_color_success" "$_color_reset"

  return_menu
}

###############################################################################
# Git options
# Second feature of Dotig: handle commit, push and pull from the script.
###############################################################################

# Commit all changes in the $DOTFILES repository.
commit_changes() {
  local _staged_files

  git -C "$DOTIG_PATH" add --all
  _staged_files=$(get_staged_files_count) || true

  if [ "$_staged_files" -ne 0 ]; then
    printf "\n"
    git -C "$DOTIG_PATH" commit
    printf "%sSuccess:%s Changes committed!\n" "$_color_success" "$_color_reset"
  else
    printf "\nCommit is not necessary, no staged files.\n"
  fi

  return_menu
}

# Push all unpushed commits in $DOTFILES repository.
push_changes() {
  local _unpushed_commits_count
  _unpushed_commits_count=$(get_unpushed_commits | wc -l)

  if [ "$_unpushed_commits_count" -ne 0 ]; then
    git -C "$DOTIG_PATH" push
    printf "\n%sSuccess:%s Commit(s) pushed!\n" "$_color_success" "$_color_reset"
  else
    printf "\nNothing to push.\n"
  fi

  return_menu
}

# Pull changes from remote repository.
pull_changes() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if ! is_repo_up_to_date "$_local_commit" "$_remote_commit" && is_pull_needed "$_local_commit" "$_common_ancestor"; then
    if ! is_repo_dirty; then
      git -C "$DOTIG_PATH" pull --rebase
      printf "\n%sSuccess:%s Repo is now up-to-date!\n" "$_color_success" "$_color_reset"
    else
      printf "\n%sWarning:%s Dotig cannot pull. Your repo is dirty.\n" "$_color_warning" "$_color_reset"
      printf "See the details below.\n"
      get_expanded_status
      printf "Commit or stash (manually) your changes if you want to pull.\n"
    fi
  else
    printf "\nNothing to pull.\n"
  fi

  return_menu
}

# Update all Git submodules.
update_all_submodules() {
  is_verbose && printf "\nChecking for Git submodules...\n"
  if has_submodules; then
    is_verbose && printf "Updating Git submodules..."
    update_submodules
    printf "\n%sSuccess:%s All submodules have been updated.\n" "$_color_success" "$_color_reset"
  else
    printf "No submodules found.\n"
  fi

  return_menu
}

###############################################################################
# Help menus
# Functions to print the various help menus.
###############################################################################

# Display the main help menu.
print_dotig_help() {
  cat <<EOF
# USAGE
dotig [OPTIONS]
dotig [-v|--verbose] <COMMANDS> [<FILES...>]

# DESCRIPTION
Dotig is a dotfiles manager to quickly setup your machine & synchronize your dotfiles with Git.

# COMMANDS
add               Add new dotfiles and create symlinks.
                  Accept both absolute and relative paths.
update            Update all symlinks.
commit            Use Git to commit all changes.
push              Use Git to push all changes.
pull              Use Git to pull changes from remote.
submodule         Update Git submodules.
rm                Replace all symlinks with the original file.
                  The original will be conserved in your repository.
status            Display the status of your dotfiles repository.
                  Check for dirty files and if push or pull is needed.

# OPTIONS
-h, --help        Print this help.
-ns, --no-status  Do not show the repo status.
-v, --verbose     Explain what is done.
--version         Print Dotig version and check for new releases.

# CONFIGURATION
DOTFILES          Environment variable to define the path of your dotfiles
                  repository. You need to declare its value in your shell
                  configuration files.
                  For example in .profile for Bash or .zshenv for Zsh.
                  Current value: $DOTFILES

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  return_menu
}

###############################################################################
# Menu
# Display all possible options.
###############################################################################

# Ask user if he wants to return to the menu or exit Dotig.
return_menu() {
  [ $_disable_menu = "true" ] && return

  local _choice

  while true; do
    printf "\nWhat do you want to do: return to the menu %s[r]%s or exit %s[q]%s? " "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset"
    read -r _choice

    case $_choice in
    [rR]) return ;;
    [qQ]) exit ;;
    *)
      printf "%sError:%s invalid choice. Please enter %s[r]%seturn or %s[e]%sxit.\n" "$_color_error" "$_color_reset" "$_color_choice" "$_color_reset" "$_color_choice" "$_color_reset"
      ;;
    esac
  done
}

# Display the list of choices available in the main menu of Dotig.
print_menu_options() {
  printf "\nChoose an action to perform:\n"
  printf "%s[1]%s Add dotfile(s) to your repo\n" "$_color_choice" "$_color_reset"
  printf "%s[2]%s Update symlinks\n" "$_color_choice" "$_color_reset"
  printf "%s[3]%s Commit dotfiles changes\n" "$_color_choice" "$_color_reset"
  printf "%s[4]%s Push changes to remote\n" "$_color_choice" "$_color_reset"
  printf "%s[5]%s Pull changes from remote\n" "$_color_choice" "$_color_reset"
  printf "%s[6]%s Update all Git submodules\n" "$_color_choice" "$_color_reset"
  printf "%s[7]%s Remove all symlinks\n" "$_color_choice" "$_color_reset"
  printf "%s[8]%s Check for Dotig update\n" "$_color_choice" "$_color_reset"
  printf "%s[9]%s Print Dotig version\n" "$_color_choice" "$_color_reset"
  printf "%s[10]%s Print Dotig help\n" "$_color_choice" "$_color_reset"
  printf "%s[q]%s Exit\n" "$_color_choice" "$_color_reset"
}

# Display the main menu of Dotig.
print_menu() {
  local _choice

  while true; do
    print_menu_options
    printf "Your choice: "
    read -r _choice

    case $_choice in
    1) add_dotfiles ;;
    2) update_symlinks ;;
    3) commit_changes ;;
    4) push_changes ;;
    5) pull_changes ;;
    6) update_all_submodules ;;
    7) remove_symlinks ;;
    8) check_dotig_updates ;;
    9) print_dotig_version ;;
    10) print_dotig_help ;;
    [qQ]) exit ;;
    *) printf "\n%sError:%s Invalid choice. Try again.\n" "$_color_error" "$_color_reset" ;;
    esac
  done
}

###############################################################################
# Main
# Entry point of Dotig.
###############################################################################

# Main entry point of Dotig.
main() {
  print_logo
  check_requirements
  is_backup_repo_ready
  set_xdg_paths
  [ $_show_repo_status = "true" ] && get_repo_status
  print_menu
}

###############################################################################
# CLI
# Handle the command line interface scenario.
###############################################################################

# Check if the first argument provided is an available command.
# Argument 1: the command to test.
is_dotig_cli_command() {
  for _command in "${DOTIG_COMMANDS[@]}"; do
    [ "$1" = "$_command" ] && return 0
  done
  return 1
}

# Redirect command to the right function.
# Require 1 or more arguments.
# Argument 1: a valid command.
handle_dotig_cli_commands() {
  [ ! "$DOTFILES" ] && error_backup_path
  [ ! -d "$DOTFILES" ] && error_backup_path
  DOTIG_PATH="$DOTFILES"
  _disable_menu="true"

  set_xdg_paths

  if [ $# -eq 1 ]; then
    case $1 in
    add) add_dotfiles ;;
    update) update_symlinks ;;
    commit) commit_changes ;;
    push) push_changes ;;
    pull) pull_changes ;;
    submodule) update_all_submodules ;;
    rm) remove_symlinks ;;
    status) get_repo_status ;;
    *) error_unexpected ;;
    esac
  else
    case $1 in
    add)
      shift
      add_dotfiles "$@"
      ;;
    *) invalid_usage ;;
    esac
  fi

  exit
}

# Change Dotig parameters according to the options passed through CLI
# Require at least one argument.
loop_through_options() {
  [ $# -eq 0 ] && error_unexpected

  while [ $# -ge 1 ]; do
    case $1 in
    --no-status|-ns)
      _show_repo_status="false"
      shift
      ;;
    --verbose|-v)
      _verbose="true"
      shift
      ;;
    *)
      if is_dotig_cli_command "$1"; then
        handle_dotig_cli_commands "$@"
      else
        invalid_usage
      fi
      ;;
    esac
  done
}

# Redirect command to the right function.
# Require 1 or more arguments.
# Argument 1: a valid option.
# Additional arguments are also valid options.
handle_dotig_cli_options() {
  [ $# -eq 0 ] && error_unexpected

  if [ $# -eq 1 ]; then
    case $1 in
    --help|-h)
      _disable_menu="true"
      print_dotig_help
      ;;
    --version)
      _disable_menu="true"
      print_dotig_version
      check_dotig_updates
      ;;
    *)
      loop_through_options "$@"
      main
      ;;
    esac
  else
    loop_through_options "$@"
    main
  fi
}

# Handle Dotig CLI.
# Require 1 or more arguments.
dotig_cli() {
  if is_dotig_cli_command "$1"; then
    handle_dotig_cli_commands "$@"
  else
    handle_dotig_cli_options "$@"
  fi
}

###############################################################################
# Run the script
###############################################################################

if [ $# -eq 0 ]; then
  main
else
  dotig_cli "$@"
fi
