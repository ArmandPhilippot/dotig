#!/usr/bin/env bash
#
# Dotig
# A dotfiles manager to quickly setup your machine & synchronize your dotfiles
# with Git.
#
# Requirements: Git, GNU/Linux, GNU Coreutils and curl.
# Tested with: Manjaro 21, Debian 10, Ubuntu 20 and Fedora 34.
# Author: Armand Philippot <https://www.armandphilippot.com/>
# URL: https://github.com/ArmandPhilippot/dotig

###############################################################################
#
# The MIT License (MIT)

# Copyright (c) 2021 Armand Philippot

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
###############################################################################

set -e

###############################################################################
# TABLE OF CONTENT
# ================
# 1. Variables
#   1.1. Globals
#   1.2. Colors
#   1.3. Parameters
# 2. Helpers
#   2.1. Miscelleanous Helpers
#   2.2. Parameters & Arguments Helpers
#   2.3. Colors Helpers
#   2.4. Paths Helpers
#   2.5. Error Helpers
#   2.6. Git Helpers
# 3. Safety Checks
# 4. Repo Configuration
# 5. Dotig Features
#   5.1. Feature: Dotfiles Symlinks
#   5.2. Feature: Git
#   5.3. Feature: Repo Status
#   5.4. Feature: Dotig Info
# 6. Help Menus
# 7. Main Menu
# 8. CLI
# 9. Entry Point
# 10. Execute Dotig
###############################################################################

###############################################################################
# 1. Variables
###############################################################################

###############################################################################
# 1.1. Globals
###############################################################################
_DOTIG_COMMANDS=("add" "update" "commit" "push" "pull" "submodule" "rm" "status" "version")
_DOTIG_LOGO=$(
  cat <<-EOF
#######################################
##      ____        _   _            ##
##     |  _ \  ___ | |_(_) __ _      ##
##     | | | |/ _ \| __| |/ _  |     ##
##     | |_| | (_) | |_| | (_| |     ##
##     |____/ \___/ \__|_|\__, |     ##
##                        |___/      ##
##                                   ##
#######################################
EOF
)
_DOTIG_REPO=""
_DOTIG_VERSION="2.0.1"

###############################################################################
# 1.2. Colors
###############################################################################
_COLOR_RESET=$(printf '\e[0m')
_COLOR_RED=$(printf '\e[31m')
_COLOR_GREEN=$(printf '\e[32m')
_COLOR_YELLOW=$(printf '\e[33m')
_COLOR_BLUE=$(printf '\e[34m')
_COLOR_MAGENTA=$(printf '\e[35m')

###############################################################################
# 1.3. Parameters
###############################################################################
# Modes
_CLI_MODE="false"
_INTERACTIVE_MODE="false"
_PRIVATE_REPO="false"
_VERBOSE="false"

# Globals parameters
_DISABLE_MENU="false"
_REPO_STATUS="false"

# Symlinking parameters
_CHECK_BROKEN_SYMLINKS="false"
_SKIP_DUPLICATE="false"
_SKIP_TARGET="false"

# Git parameters
_COMMIT_FILES="all"

# Status parameters
_LIST_DIRTY="false"

###############################################################################
# 2. Helpers
# Various helpers used across the script in different locations.
###############################################################################

###############################################################################
# 2.1. Miscelleanous Helpers
###############################################################################

# Print Dotig logo
print_logo() {
  printf "%s\n\n" "$_DOTIG_LOGO"
}

# Check if the current OS is GNU/Linux.
is_linux() {
  [ "$OSTYPE" = "linux-gnu" ]
}

# Check if the provided command is installed.
is_command_installed() {
  [ -x "$(command -v "$1")" ]
}

# Print a spinner
spinner() {
  local _pid=$!
  local _delay=0.25
  local _spinstr='-\|/'
  local _i=0

  while kill -0 $_pid 2>/dev/null; do
    _i=$(((_i + 1) % 4))
    printf "[%s]\r" "${_spinstr:$_i:1}"
    sleep $_delay
  done
}

###############################################################################
# 2.2. Parameters & Arguments Helpers
# Functions to handle Dotig parameters/arguments.
###############################################################################

# Check if CLI mode is activated.
is_cli_mode() {
  [ "$_CLI_MODE" = "true" ]
}

# Check if interactive mode is activated.
is_interactive_mode() {
  [ "$_INTERACTIVE_MODE" = "true" ]
}

# Check if verbose mode is activated.
is_verbose_mode() {
  [ "$_VERBOSE" = "true" ]
}

# Check if the first argument provided is an available command.
# Argument 1: the command to test.
is_dotig_cli_command() {
  for _command in "${_DOTIG_COMMANDS[@]}"; do
    [ "$1" = "$_command" ] && return 0
  done
  return 1
}

# Check if the argument passed is the help option.
# Argument 1: the option to test.
is_help_option() {
  [ $# -ne 1 ] && error_unexpected

  [ "$1" = "-h" ] || [ "$1" = "--help" ]
}

# Initialize default parameters if a command is used.
set_cli_default_parameters() {
  _CLI_MODE="true"
  _DISABLE_MENU="true"
  _SKIP_DUPLICATE="true"
  _SKIP_TARGET="true"
}

# Initialize default parameters if interactive mode is use.
set_interactive_default_parameters() {
  _INTERACTIVE_MODE="true"
  _SKIP_DUPLICATE="false"
  _SKIP_TARGET="false"
}

###############################################################################
# 2.3. Colors Helpers
# Functions to print some messages in color or not.
###############################################################################

option() {
  printf "%s%s%s\n" "$_COLOR_BLUE" "$1" "$_COLOR_RESET"
}

highlight() {
  printf "%s%s%s\n" "$_COLOR_MAGENTA" "$1" "$_COLOR_RESET"
}

error() {
  printf "%sError:%s %s\n" "$_COLOR_RED" "$_COLOR_RESET" "$1"
}

success() {
  printf "%sSuccess:%s %s\n" "$_COLOR_GREEN" "$_COLOR_RESET" "$1"
}

warning() {
  printf "%sWarning:%s %s\n" "$_COLOR_YELLOW" "$_COLOR_RESET" "$1"
}

skipped() {
  printf "%sSkipped:%s %s\n" "$_COLOR_YELLOW" "$_COLOR_RESET" "$1"
}

status() {
  local _option=$1
  local _msg=$2
  local _status_color

  case $_option in
  -s) _status_color=$_COLOR_GREEN ;;
  -w) _status_color=$_COLOR_YELLOW ;;
  esac

  printf "Status: %s%s%s\n" "$_status_color" "$_msg" "$_COLOR_RESET"
}

verbose() {
  if is_verbose_mode; then
    printf "%s\n" "$1"
  fi
}

###############################################################################
# 2.4. Paths Helpers
# Various functions to handle paths (set, normalize, convert...).
###############################################################################

# Return the absolute path.
# Argument 1: a path to convert.
get_absolute_path() {
  [ $# -ne 1 ] && error_unexpected

  local path=$1
  local _absolute_path

  case $path in
  /*) _absolute_path=$path ;;
  \~/*) _absolute_path="$HOME/${path:2}" ;;
  ./*) _absolute_path="$(pwd)/${path:2}" ;;
  *) _absolute_path="$(pwd)/$path" ;;
  esac

  printf "%s\n" "$_absolute_path"
}

# Add a trailing slash to the path if it is missing.
# Argument 1: a directory path
# Return the normalized path.
normalize_path() {
  local _path=$1

  case $_path in
  */) : ;;
  *) _path="${_path}/" ;;
  esac

  printf "%s\n" "$_path"
}

# Check if the provided path is an existent directory.
# Argument 1: the path to test
is_valid_directory() {
  local _dir=$1

  if [ ! "$_dir" ] || [ ! -d "$_dir" ]; then
    return 1
  fi

  return 0
}

# Ask user if the provided path is correct.
# Argument 1: the path to test.
is_correct_path() {
  [ $# -ne 1 ] && error_unexpected

  local _path=$1
  local _validation

  while true; do
    printf "Is %s correct? [$(option "y")/$(option "n")] " "$(highlight "$_path")"
    read -r _validation

    case $_validation in
    [yY]) return 0 ;;
    [nN]) return 1 ;;
    *) error "Please enter $(option "y") (yes) or $(option "n") (no)." ;;
    esac
  done
}

# Prompt user to define an existing directory path.
# Return the entered path.
ask_path() {
  local _path

  while [ ! -d "$_path" ]; do
    printf "Set the path: " >&2
    read -r -e _path
    _path=$(get_absolute_path "$_path")

    [ ! -d "$_path" ] && error "$(highlight "$_path") is not a directory." >&2
  done <&2

  _path=$(normalize_path "$_path")
  printf "%s\n" "$_path"
}

# Check if a file is in the provided path.
# Argument 1: the file to test
# Argument 2: the path
is_file_in() {
  [ $# -ne 2 ] && error_unexpected

  local _file=$1
  local _tested_path=$2

  case $_file in
  "$_tested_path"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Use XDG Specification to handle dotfiles and symlinks.
# Check if XDG path are set, if not set them.
set_xdg_paths() {
  if is_linux; then
    XDG_BIN_HOME=${XDG_BIN_HOME:-$HOME/.local/bin}
    XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
    XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
    XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
    XDG_LIB_HOME=${XDG_LIB_HOME:-$HOME/.local/lib}
    XDG_STATE_HOME=${XDG_STATE_HOME:-$HOME/.local/state}
  else
    error "Only Linux is supported."
    exit 2
  fi
}

# Convert a file path to Dotig format based on XDG Specification.
# Argument 1: a path to convert.
convert_to_dotig_format() {
  [ $# -ne 1 ] && error_unexpected
  local _dotfile=$1
  local _dotig_format
  local _partial_dest
  local _removed_part

  case $_dotfile in
  "$XDG_BIN_HOME"*)
    _partial_dest="home/xdg_bin"
    _removed_part=$XDG_BIN_HOME
    ;;
  "$XDG_CACHE_HOME"*)
    _partial_dest="home/xdg_cache"
    _removed_part=$XDG_CACHE_HOME
    ;;
  "$XDG_CONFIG_HOME"*)
    _partial_dest="home/xdg_config"
    _removed_part=$XDG_CONFIG_HOME
    ;;
  "$XDG_DATA_HOME"*)
    _partial_dest="home/xdg_data"
    _removed_part=$XDG_DATA_HOME
    ;;
  "$XDG_LIB_HOME"*)
    _partial_dest="home/xdg_lib"
    _removed_part=$XDG_LIB_HOME
    ;;
  "$XDG_STATE_HOME"*)
    _partial_dest="home/xdg_state"
    _removed_part=$XDG_STATE_HOME
    ;;
  "$HOME"*)
    _partial_dest="home"
    _removed_part=$HOME
    ;;
  *) _dotfile=${_dotfile/\//} ;;
  esac

  _dotig_format=${_DOTIG_REPO}${_partial_dest}${_dotfile#$_removed_part}
  printf "%s\n" "$_dotig_format"
}

# Convert a file path to $HOME format based on XDG Specification.
# Argument 1: a path to convert.
convert_to_home_format() {
  [ $# -ne 1 ] && error_unexpected
  local _dotfile=$1
  local _home_format
  local _partial_dest
  local _removed_part

  case $_dotfile in
  "${_DOTIG_REPO}home/xdg_bin"*)
    _partial_dest=$XDG_BIN_HOME
    _removed_part="home/xdg_bin"
    ;;
  "${_DOTIG_REPO}home/xdg_cache"*)
    _partial_dest=$XDG_CACHE_HOME
    _removed_part="home/xdg_cache"
    ;;
  "${_DOTIG_REPO}home/xdg_config"*)
    _partial_dest=$XDG_CONFIG_HOME
    _removed_part="home/xdg_config"
    ;;
  "${_DOTIG_REPO}home/xdg_data"*)
    _partial_dest=$XDG_DATA_HOME
    _removed_part="home/xdg_data"
    ;;
  "${_DOTIG_REPO}home/xdg_lib"*)
    _partial_dest=$XDG_LIB_HOME
    _removed_part="home/xdg_lib"
    ;;
  "${_DOTIG_REPO}home/xdg_state"*)
    _partial_dest=$XDG_STATE_HOME
    _removed_part="home/xdg_state"
    ;;
  "${_DOTIG_REPO}home"*)
    _partial_dest=$HOME
    _removed_part="home"
    ;;
  *) _partial_dest="/" ;;
  esac

  _home_format=${_partial_dest}${_dotfile#${_DOTIG_REPO}${_removed_part}}
  printf "%s\n" "$_home_format"
}

# Create any missing directory in a provided path.
# Argument 1: a path.
create_file_path() {
  [ $# -ne 1 ] && error_unexpected
  local _file=$1

  verbose "Creating any missing directory..."
  mkdir -p "$(dirname "$_file")"
  verbose "$(success "Any missing directories have been created.")"
}

# Move file from its source to its destination.
# Argument 1: a file path.
# Argument 2: the file destination.
move_file() {
  [ $# -ne 2 ] && error_unexpected
  local _source=$1
  local _dest=$2

  verbose "Moving $(highlight "$_source") to $(highlight "$_dest")..."
  mv "$_source" "$_dest"
  verbose "$(success "$(highlight "$_source") moved.")"
}

# Symlink a file.
# Argument 1: a file path.
# Argument 2: the symlink destination.
symlink_file() {
  [ $# -ne 2 ] && error_unexpected
  local _source_file=$1
  local _symlink_dest=$2

  verbose "Symlinking $(highlight "$_source_file") to $(highlight "$_symlink_dest")..."
  ln -s "$_source_file" "$_symlink_dest"
  success "Symlink $(highlight "$_symlink_dest") created."
}

# Copy a file from a path to another.
# Argument 1: a file path.
# Argument 2: the file destination.
copy_file() {
  [ $# -ne 2 ] && error_unexpected
  local _source_path=$1
  local _copy_path=$2

  verbose "Copying $(highlight "$_source_path") to $(highlight "$_copy_path")..."
  cp "$_source_path" "$_copy_path"
  verbose "$(success "$(highlight "$_source_path") copied.")"
}

# Remove a file in $HOME.
# Argument 1: a file path.
remove_file() {
  [ $# -ne 1 ] && error_unexpected
  local _dotfile=$1

  verbose "Removing $(highlight "$_dotfile")..."
  if is_file_in "$_dotfile" "$HOME"; then
    rm "$_dotfile"
    verbose "$(success "$(highlight "$_dotfile") removed.")"
    return 0
  else
    error "$(highlight "$_dotfile") is not in \$HOME, cannot remove it."
    return 1
  fi
}

###############################################################################
# 2.5. Error Helpers
# Functions to handle the various error messages.
###############################################################################

# Clean up temporary files then exit.
cleanup() {
  verbose $'\n\nDeleting temporary files...'
  rm -f "$_tmp"
  verbose "$(success "Temporary files deleted.")"
  verbose "Exit."
  exit
}

# Display an error in case of an unplanned scenario then exit.
error_unexpected() {
  error "An unexpected error occurred."
  printf "Exit.\n"
  cleanup
  exit 1
}

# Display an error in case of invalid usage then exist.
invalid_usage() {
  error "Invalid usage."

  if [ $# -eq 1 ]; then
    local _command_name=$1

    printf "Use \`dotig %s --help\` or \`dotig %s -h\` to display all accepted options.\n" "$_command_name" "$_command_name"
  else
    printf "Use \`dotig --help\` or \`dotig -h\` to display all accepted commands and options.\n"
  fi

  exit 1
}

# Display an error if repo not set then exit.
error_repo_not_set() {
  error "Without interactive mode, $(get_requested_env_var) need to be set."
  printf "Try again with --interactive (or -i) option or set %s.\n" "$(get_requested_env_var)"
  printf "Exit.\n"
  cleanup
  exit 1
}

# Display an error if Git is not configured.
error_git_not_configured() {
  error "Without interactive mode, Git need to be configured."
  printf "Try again with --interactive (or -i) option or configure Git manually.\n"
  printf "Exit.\n"
  cleanup
  exit 1
}

# Execute cleanup function if these signals are caught.
trap cleanup SIGHUP SIGINT SIGQUIT SIGTERM

###############################################################################
# 2.6. Git Helpers
# Git specific helpers used in different locations across the script.
###############################################################################

# Return the branch name on which the working tree is on.
get_current_branch() {
  git -C "$_DOTIG_REPO" symbolic-ref --quiet --short HEAD
}

# Return the upstream name for the current branch.
get_upstream_name() {
  local _git_branch
  _git_branch=$(get_current_branch)
  git -C "$_DOTIG_REPO" config branch."$_git_branch".remote 2>/dev/null
}

# Get the remote branch name of the current repository.
get_remote_branch() {
  [ $# -ne 1 ] && error_unexpected
  git -C "$_DOTIG_REPO" ls-remote --symref "$1" HEAD | head -1 | sed 's@ref: refs/heads/@@' | cut -f1
}

# Return a list of existing Git remotes.
get_existing_remotes() {
  git -C "$_DOTIG_REPO" remote
}

# Download objects and refs from remote.
fetch_remote() {
  git -C "$_DOTIG_REPO" fetch
}

# Return the object name of the current commit on the working tree.
get_local_commit() {
  git -C "$_DOTIG_REPO" rev-parse --verify -q HEAD
}

# Check if the local repo has at least one commit.
has_local_commit() {
  local _commit_count
  _commit_count=$(get_local_commit | wc -l) || true
  [ "$_commit_count" -ge 1 ]
}

# Return the object name of the last commit on the remote.
get_remote_commit() {
  git -C "$_DOTIG_REPO" rev-parse --verify -q FETCH_HEAD
}

# Return a good common ancestor if the working tree has at least one commit.
get_common_ancestor() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" ] && git -C "$_DOTIG_REPO" merge-base HEAD "$_remote_commit"
}

# Check if the current commit and the last commit on the remote are the same.
is_repo_up_to_date() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" = "$_remote_commit" ]
}

# Check if the remote is ahead the working tree.
is_pull_needed() {
  local _local_commit=$1
  local _common_ancestor=$2

  [ "$_local_commit" = "$_common_ancestor" ]
}

# Check if the remote is behind the working tree.
is_push_needed() {
  local _remote_commit=$1
  local _common_ancestor=$2

  [ "$_remote_commit" = "$_common_ancestor" ]
}

# Return the number of changed files (modified, deleted...) on the working tree.
get_dirty_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | wc -l
}

# Check if the working tree has changed files.
is_repo_dirty() {
  local _dirty_files_count
  _dirty_files_count=$(get_dirty_files_count)

  [ "$_dirty_files_count" -ne 0 ]
}

# Return the number of untracked files.
get_untracked_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | grep -c "^??"
}

# Return the number of staged files.
get_staged_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | grep -c "^[A|M]"
}

# Return the number of deleted files.
get_deleted_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | grep -c "^.D"
}

# Return the number of renamed files.
get_renamed_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | grep -c "^R"
}

# Return the number of modified files.
get_modified_files_count() {
  git -C "$_DOTIG_REPO" status --porcelain | grep -c "^.M"
}

# Return the number of unmerged files.
get_unmerged_files_count() {
  git -C "$_DOTIG_REPO" ls-files --unmerged | wc -l
}

# Return the number of stash.
get_stashed_count() {
  git -C "$_DOTIG_REPO" stash list | wc -l
}

# Return the list of unpushed commits.
get_unpushed_commits() {
  local _remote
  local _branch

  _remote=$(get_upstream_name)
  _branch=$(get_current_branch)

  has_local_commit && git -C "$_DOTIG_REPO" log --oneline "$_remote"/"$_branch"..HEAD
}

# Check if the repo has Git submodules.
has_submodules() {
  local _tmp
  local _submodules

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  git -C "$_DOTIG_REPO" submodule status >"$_tmp"

  while IFS='' read -r line; do _submodules+=("$line"); done <"$_tmp"

  rm "$_tmp"

  [ "${#_submodules[@]}" -gt 0 ]
}

# Update all the Git submodules.
update_submodules() {
  git -C "$_DOTIG_REPO" submodule update --init --recursive
}

# Return a list of Git submodule paths.
get_submodules_path() {
  # shellcheck disable=SC2016
  git -C "$_DOTIG_REPO" submodule -q foreach 'printf ${sm_path}"\n"'
}

# Check if the dotfiles backup directory is a Git repository.
is_git_repo() {
  git -C "$_DOTIG_REPO" rev-parse --git-dir >/dev/null 2>&1
}

# Check if the remote is set.
is_remote_set() {
  git -C "$_DOTIG_REPO" config --get-regexp '^remote\.' >/dev/null 2>&1
}

# Check if the provided remote name exists.
# Argument 1: the remote to test.
# Argument 2: a list of existing remotes.
is_valid_remote_name() {
  [ $# -ne 2 ] && error_unexpected

  case $2 in
  *"$1"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Check if the provided remote URL is a supported URL.
# Argument 1: the URL to test.
is_valid_remote_url() {
  [ $# -ne 1 ] && error_unexpected

  local _remote_url=$1

  case $_remote_url in
  "https"* | "git@"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Check if the provided URL is an existing remote.
# Argument 1: the URL to test.
is_existing_remote() {
  local _remote=$1

  git ls-remote "$_remote" >/dev/null 2>&1
}

###############################################################################
# 3. Safety Checks
# Do not execute Dotig if requirements are not met.
###############################################################################

# Check for supported OS.
check_os() {
  verbose "Identifying the operating system..."

  if is_linux; then
    verbose "$(success "Operating system identified. Linux is supported.")"
  else
    error "Linux is the only supported operating system."
    printf "Exit.\n"
    exit 1
  fi
}

# Check if Git is installed.
is_git_installed() {
  verbose "Checking if Git is installed..."
  if is_command_installed "git"; then
    verbose "$(success "Git is installed.")"
  else
    error "Dotig needs Git to function properly."
    printf "Please install it before using this program.\n"
    printf "Exit.\n"
    exit 1
  fi
}

# Check if curl is installed.
is_curl_installed() {
  verbose "Checking if curl is installed..."
  if is_command_installed "curl"; then
    verbose "$(success "curl is installed.")"
  else
    warning "curl is needed to check for Dotig update. Please install it if you want to use this feature."
  fi
}

# Check if the required commands are available.
check_commands() {
  verbose "Checking installed programs..."
  is_git_installed
  is_curl_installed
  verbose "$(success "Programs checked.")"
}

# Check if all the requirements are met.
check_requirements() {
  verbose "Checking requirements..."
  check_os
  check_commands
  verbose "$(success "Requirements checked!")"
  verbose $'Let\'s continue.\n'
}

###############################################################################
# 4. Repo Configuration
# Check the environment variable are defined and if it is a repo.
# If not, set both.
###############################################################################

# Return the environment variable name according to private paramater.
get_requested_env_var() {
  local _env_var

  if [ "$_PRIVATE_REPO" = "true" ]; then
    _env_var="\$DOTFILES_PRIVATE"
  else
    _env_var="\$DOTFILES"
  fi

  printf "%s\n" "$_env_var"
}

# Set _DOTIG_REPO with the correct format.
# Check if environment variables are set, if not ask user for a valid path.
set_dotfiles_repo() {
  verbose "Checking if your dotfiles repository is set in your shell..."

  if [ "$_PRIVATE_REPO" = "true" ]; then
    _DOTIG_REPO="$DOTFILES_PRIVATE"
  else
    _DOTIG_REPO="$DOTFILES"
  fi

  if [ -z "$_DOTIG_REPO" ]; then
    warning "You did not define $(get_requested_env_var) in your shell configuration."
    verbose "For conveniance, Dotig uses \$DOTFILES and \$DOTFILES_PRIVATE variables to determine your dotfiles repos."
    verbose $'If they are not set, you may want to declare them for future use.\n'

    if is_interactive_mode; then
      _DOTIG_REPO=$(ask_path)
    else
      error_repo_not_set
    fi
  elif ! is_valid_directory "$_DOTIG_REPO"; then
    warning "It seems $(get_requested_env_var) does not contain a valid directory."

    if is_interactive_mode; then
      _DOTIG_REPO=$(ask_path)
    else
      error_repo_not_set
    fi
  fi

  if is_interactive_mode; then
    while ! is_correct_path "$_DOTIG_REPO"; do
      _DOTIG_REPO=$(ask_path)
    done
  fi

  _DOTIG_REPO=$(get_absolute_path "$_DOTIG_REPO")
  _DOTIG_REPO=$(normalize_path "$_DOTIG_REPO")

  verbose "$(success "Dotfiles directory set.")"
}

# Ask the remote name when multiple remotes exist.
# Return the remote name.
ask_remote_name() {
  local _git_remotes
  local _current_branch
  local _remote_name

  _git_remotes=$(get_existing_remotes)
  _current_branch=$(get_current_branch)

  warning "Your repo contains multiple remotes:" >&2
  option "$_git_remotes" >&2
  while true; do
    printf "\nChoose the remote to use for %s: " "$(highlight "$_current_branch")" >&2
    read -r _remote_name

    is_valid_remote_name "$_remote_name" "$_git_remotes" && break
    error "Remote name invalid. Use one of:" >&2
    option "$_git_remotes" >&2
  done <&2

  printf "%s\n" "$_remote_name"
}

# Define the upstream branch and update the local repo.
set_upstream_branch() {
  local _git_remotes
  local _remote_name
  local _remote_branch

  verbose "Setting upstream branch..."

  _git_remotes=$(get_existing_remotes)

  if [ "$(printf "%s\n" "$_git_remotes" | wc -l)" -gt 1 ]; then
    _remote_name=$(ask_remote_name)
  else
    _remote_name=$_git_remotes
  fi

  _remote_branch=$(get_remote_branch "$_remote_name")

  git -C "$_DOTIG_REPO" fetch "$_remote_name"
  git -C "$_DOTIG_REPO" checkout -t "$_remote_name"/"$_remote_branch"
}

# Check if the provided remote URL is a remote repository.
# Argument 1: the URL to test.
is_valid_remote() {
  [ $# -ne 1 ] && error_unexpected

  local -n _valid_remote=$1

  if [ -n "$_valid_remote" ]; then
    ! is_valid_remote_url "$_valid_remote" && printf "\n" && error "The remote URL is not valid. URL must starts with $(highlight "https") or $(highlight "git@")." && return 1

    printf "\nChecking if the provided remote exists. Your SSH passphrase can be requested.\n"

    ! is_existing_remote "$_valid_remote" && error "This remote URL does not exist." && return 1

    return 0
  else
    return 1
  fi
}

# Define the remote repository.
set_remote() {
  local _remote

  verbose $'\nDotig needs to know your remote to perform some actions (status, push, pull).'
  verbose "Setting Git remote..."

  while ! is_valid_remote _remote; do
    printf "Please enter your remote address: "
    read -r _remote
  done

  git -C "$_DOTIG_REPO" remote add origin "$_remote"
}

# Initialize a new Git repository with remote, upstream and submodules.
configure_git() {
  verbose "Checking if remote is set..."
  ! is_remote_set && set_remote
  verbose "$(success "Remote set.")"
  verbose "Checking if upstream is set..."
  [ -z "$(get_upstream_name)" ] && set_upstream_branch
  verbose "$(success "Upstream set.")"
  if has_submodules; then
    verbose "Updating submodules..."
    update_submodules
    verbose "$(success "All submodules have been initialized and updated.")"
  fi
  verbose "$(success "Git initialized.")"
}

# Ask user if he wants to set the git repo then init git or exit.
ask_to_init_git() {
  printf "\n"
  warning "Your dotfiles directory is not a Git repository."

  while true; do
    printf "Do you want to configure it? [%s/%s] " "$(option "y")" "$(option "n")"
    read -r _choice

    case $_choice in
    [yY]) return 0 ;;
    [nN])
      warning $'\nDotig needs a Git repository to properly function. Please configure it manually before using this program.'
      printf "Exit.\n"
      exit
      ;;
    *) error "Enter $(option "y") (yes) or $(option "n") (no)." ;;
    esac
  done
}

# Check if the Git repository is ready, if not complete the configuration.
check_git_configuration() {
  local _choice

  verbose $'\nChecking if Git is configured...'

  if ! is_git_repo; then
    if is_interactive_mode; then
      ask_to_init_git
      verbose "Git initialization..."
      git -C "$_DOTIG_REPO" init
      verbose "$(success "Git initialized.")"
    else
      error_git_not_configured
    fi
  fi

  configure_git
  verbose "$(success "Git is configured.")"
}

# Initialize repo by checking path and Git configuration.
init_dotfiles_repo() {
  verbose "Checking if your dotfiles repo is ready..."
  set_dotfiles_repo
  check_git_configuration
  verbose "$(success "Your dotfiles repo is ready.")"
}

###############################################################################
# 5. Dotig Features
###############################################################################

###############################################################################
# 5.1. Feature: Dotfiles Symlinks
# Handle dotfiles backup and symlinks update/removal.
###############################################################################

# Move or copy dotfile to Dotig repo and symlink it if it is in $HOME.
# Argument 1: a dotfile path.
# Argument 2: the backup destination.
create_dotfile_backup() {
  [ $# -ne 2 ] && error_unexpected
  local _dotfile=$1
  local _backup=$2

  create_file_path "$_backup"

  if is_file_in "$_dotfile" "$HOME"; then
    move_file "$_dotfile" "$_backup"
    symlink_file "$_backup" "$_dotfile"
  else
    copy_file "$_dotfile" "$_backup"
    warning "Symlink will not be created. $(highlight "$_source_path") is not in \$HOME!"
  fi
}

# Display the diff between two files.
# Argument 1: the file residing in $HOME.
# Argument 2: the file residing in Dotig repo.
print_dotfiles_diff() {
  [ $# -ne 2 ] && error_unexpected
  local _dotfile=$1
  local _backup=$2
  local _filename
  local _column_width
  local _padding
  local _padding_lenght
  local _divider

  verbose "Checking diff..."
  [ ! $COLUMNS ] && COLUMNS=$(stty size | awk '{print $2}')
  _column_width=$(("$COLUMNS" / 2))
  _filename=$(basename "$_dotfile")
  _padding=$(printf '%*s' "$COLUMNS" "")
  _padding_lenght=$((_column_width - ${#HOME}))
  _divider=${_padding// /=}

  if diff -q "$_dotfile" "$_backup" >/dev/null 2>&1; then
    success "Both files are identical."
  else
    printf "\n"
    warning "The two files are different. See the diff of $(highlight "$_filename"):"
    printf "%s%0.${_padding_lenght}s%s\n" "$HOME" "$_padding" "$_DOTIG_REPO"
    printf "%s\n" "$_divider"
    command diff --color -y --width="$COLUMNS" -t --suppress-common-lines "$_dotfile" "$_backup" || [ $? -eq 1 ]
  fi

  verbose "$(success "Diff checked.")"
  printf "\n"
}

# Ask how to handle existing dotfile in $HOME that matches a file in Dotig repo.
# Argument 1: a dotfile in $HOME.
# Argument 2: a backup in Dotig rpeo.
ask_duplicate_dotfile() {
  [ $# -ne 2 ] && error_unexpected
  local _dotfile=$1
  local _backup=$2
  local _user_choice

  printf "\n"
  verbose "Handling duplicate..."
  warning "Both $(highlight "$_dotfile") and $(highlight "$_backup") already exist."
  [ -h "$_dotfile" ] && warning "$(highlight "$_dotfile") is a symlink."
  [ -h "$_backup" ] && warning "$(highlight "$_backup") is a symlink."

  while true; do
    printf "How do you want to proceed?\n"
    printf "[%s] Show diff\n" "$(option "1")"
    printf "[%s] Keep %s (delete the other)\n" "$(option "2")" "$(highlight "$_dotfile")"
    printf "[%s] Keep %s (delete the other)\n" "$(option "3")" "$(highlight "$_backup")"
    printf "[%s] Skip\n" "$(option "4")"
    printf "Your choice: "
    read -r _user_choice

    case $_user_choice in
    1) print_dotfiles_diff "$_dotfile" "$_backup" ;;
    2)
      create_dotfile_backup "$_dotfile" "$_backup"
      break
      ;;
    3)
      if remove_file "$_dotfile"; then
        symlink_file "$_backup" "$_dotfile"
      else
        skipped "$_dotfile"
      fi
      break
      ;;
    4)
      skipped "$_dotfile"
      break
      ;;
    *)
      printf "\n"
      error "Choose between $(option "1"), $(option "2"), $(option "3") or $(option "4")."
      ;;
    esac
  done

  verbose "$(success "Duplicate handled.")"
}

# Move the provided dotfiles to Dotig repo.
# Accept 0 or more arguments. If arguments are provided, files are expected.
add_dotfiles() {
  local _dotfiles
  local _dotfile
  local _backup_dotfile

  if [ $# -eq 0 ]; then
    printf "\nDotfiles to add: "
    read -r -e -a _dotfiles
  else
    _dotfiles=("$@")
  fi

  verbose "Adding new dotfile(s)..."

  for _dotfile in "${_dotfiles[@]}"; do
    _dotfile=$(get_absolute_path "$_dotfile")
    [ ! -e "$_dotfile" ] && error "$(highlight "$_dotfile") is not a file." && exit 2
    _backup_dotfile=$(convert_to_dotig_format "$_dotfile")

    if [ -e "$_backup_dotfile" ]; then
      ask_duplicate_dotfile "$_dotfile" "$_backup_dotfile"
    else
      create_dotfile_backup "$_dotfile" "$_backup_dotfile"
    fi
  done

  verbose "$(success "Dotfile(s) have been added.")"
  return_menu
}

# Find all dotfiles in the Dotig repo excluding submodules.
# Return a list of files.
get_backup_dotfiles() {
  local _exclude_dirs=()
  local _find_cmd
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_submodules_path >"$_tmp"

  while IFS='' read -r line; do _exclude_dirs+=("$line"); done <"$_tmp"

  rm "$_tmp"
  _exclude_dirs+=('.git')
  _find_cmd=(find "$_DOTIG_REPO" -mindepth 2 \( -type f -o -type l \))

  for _exclude_dir in "${_exclude_dirs[@]}"; do
    _find_cmd+=(-not \( -path "$_DOTIG_REPO${_exclude_dir}/*" -prune \))
  done

  _find_cmd+=(-print)
  "${_find_cmd[@]}"
}

# Find all broken symlinks in $HOME whose target is in $DOTFILES.
get_broken_symlinks() {
  find "$HOME" -type l -not \( -path "$_DOTIG_REPO/*" -prune \) -ilname "$_DOTIG_REPO*" ! -exec test -e {} \; -print
}

# Remove broken symlinks in $HOME whose target is in Dotig repo.
remove_broken_symlinks() {
  local _tmp
  local _file

  verbose $'\nChecking for broken symlinks...'
  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_broken_symlinks >"$_tmp" &
  spinner

  if [ -s "$_tmp" ]; then
    verbose "Removing broken symlinks..."

    while IFS= read -r _file <&3; do
      remove_file "$_file"
    done 3<"$_tmp" &

    success "All broken symlinks removed."
  else
    success "No broken symlinks found."
  fi

  rm "$_tmp"
  verbose "$(success "Broken symlinks checked.")"
}

# Ask user if he wants to check for broken symlinks.
ask_remove_broken_symlinks() {
  local _user_choice

  printf "\nDo you want to check for broken symlinks? [%s/%s] " "$(option "y")" "$(option "n")"
  read -r _user_choice

  case $_user_choice in
  [yY])
    remove_broken_symlinks
    ;;
  [nN]) : ;;
  *) error "Invalid option. Enter $(option "y") (yes) or $(option "n") (no)." ;;
  esac
}

# Ask user which action to perform in case of symlink target conflict.
# Argument 1: a backup in Dotig repo.
# Argument 2: the symlink in $HOME.
ask_target_conflict() {
  [ $# -ne 2 ] && error_unexpected
  local _backup=$1
  local _home_symlink=$2
  local _user_choice

  while true; do
    printf "How do you want to proceed?\n"
    printf "[%s] Replace\n" "$(option "1")"
    printf "[%s] Skip\n" "$(option "2")"
    printf "Your choice: "
    read -r _user_choice

    case $_user_choice in
    1)
      return 0
      break
      ;;
    2)
      return 1
      break
      ;;
    *) error "Enter $(option "1") or $(option "2")." ;;
    esac
  done
}

# Handle symlink whose target does not match backup in Dotig repo.
# Argument 1: a backup in Dotig repo.
# Argument 2: the symlink in $HOME.
# Argument 3: the symlink target.
handle_target_conflict() {
  [ $# -ne 3 ] && error_unexpected
  local _backup=$1
  local _home_symlink=$2
  local _home_symlink_target=$3
  local _backup_target
  local _file_info

  if [ -h "$_backup" ]; then
    _file_info=" (also a symlink)"
    _backup_target=$(readlink -f "$_backup") || true
    [ -z "$_backup_target" ] && _backup_target="Target does not exist."
  fi

  warning "A symlink exists but its target does not match your dotfile backup."
  warning "Symlink: $(highlight "$_home_symlink")"
  warning "Symlink target: $(highlight "$_home_symlink_target")"
  warning "Backup${_file_info}: $(highlight "$_backup")"
  [ -h "$_backup" ] && warning "Backup target: $(highlight "$_backup_target")"

  if ask_target_conflict "$_backup" "$_home_symlink"; then
    verbose "Updating symlink target..."
    ln -s -f "$_backup" "$_home_symlink"
    success "$(highlight "$_home_symlink") updated."
  else
    skipped "$(highlight "$_backup")"
  fi
}

# Check if symlink target matches backup in Dotig repo.
# Argument 1: a backup in Dotig repo.
# Argument 2: the symlink in $HOME.
check_symlink_target() {
  [ $# -ne 2 ] && error_unexpected
  local _backup=$1
  local _home_symlink=$2
  local _home_symlink_target

  verbose "Handling target conflict..."
  _home_symlink_target=$(readlink -f "$_home_symlink") || true
  [ -z "$_home_symlink_target" ] && _home_symlink_target="Target does not exist."

  if [ "$_home_symlink_target" = "$_backup" ]; then
    skipped "$(highlight "$_home_symlink") is up-to-date."
  else
    if [ $_SKIP_TARGET = "true" ]; then
      skipped "$(highlight "$_home_symlink") (different target)."
    else
      handle_target_conflict "$_backup" "$_home_symlink" "$_home_symlink_target"
    fi
  fi

  verbose "$(success "Target conflict handled.")"
}

# Update dotfiles in $HOME based on those in Dotig repo.
# Argument 1: a file in Dotig repo.
# Argument 2: the symlink destination.
update_dotfiles_in_home() {
  [ $# -ne 2 ] && error_unexpected
  local _source=$1
  local _dest=$2

  if [ -h "$_dest" ]; then
    check_symlink_target "$_source" "$_dest"
  elif [ -f "$_dest" ]; then
    if [ $_SKIP_DUPLICATE = "true" ]; then
      skipped "$(highlight "$_dest") (duplicate)."
    else
      ask_duplicate_dotfile "$_dest" "$_source"
    fi
  else
    create_file_path "$_dest"
    symlink_file "$_source" "$_dest"
  fi
}

# Update files on user computer based on those in Dotig repo.
update_symlinks() {
  local _backup_dotfile
  local _dotfile
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_backup_dotfiles >"$_tmp"
  verbose $'\nUpdating symlinks...'

  if [ -s "$_tmp" ]; then
    while IFS= read -r _backup_dotfile <&3; do
      _dotfile=$(convert_to_home_format "$_backup_dotfile")
      if is_file_in "$_dotfile" "$HOME"; then
        update_dotfiles_in_home "$_backup_dotfile" "$_dotfile"
      else
        warning "$(highlight "$_dotfile") is not in \$HOME. Symlink will not be created."
      fi
    done 3<"$_tmp"

    printf "\n"
    success "Done. Symlinks have been updated except the ones you chose to skip and those that require administrator rights."
  else
    printf "No symlink to update.\n"
  fi

  rm "$_tmp"

  if ! is_cli_mode || is_interactive_mode; then
    ask_remove_broken_symlinks
  elif is_cli_mode && [ "$_CHECK_BROKEN_SYMLINKS" = "true" ]; then
    remove_broken_symlinks
  fi

  return_menu
}

# Replace symlinks in $HOME that match a backup in Dotig repo.
remove_symlinks() {
  local _backup
  local _symlink
  local _symlink_target
  local _tmp

  printf "\nReplacing symlinks in \$HOME with a copy of files in %s...\n" "$(get_requested_env_var)"

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  find "$HOME" -type l -not \( -path "$_DOTIG_REPO/*" -prune \) -ilname "$_DOTIG_REPO*" -print >"$_tmp"

  if [ -s "$_tmp" ]; then
    while IFS= read -r _symlink <&3; do
      _symlink_target=$(readlink "$_symlink") || true
      _backup=$(convert_to_dotig_format "$_symlink")

      if [ "$_backup" = "$_symlink_target" ]; then
        remove_file "$_symlink"
        copy_file "$_backup" "$_symlink"
      else
        if ask_target_conflict "$_backup" "$_symlink"; then
          remove_file "$_symlink"
          copy_file "$_backup" "$_symlink"
        else
          skipped "$(highlight "$_symlink")"
        fi
      fi
    done 3<"$_tmp"

    printf "\n"
    success "Done. Symlinks have been replaced except the ones you chose to skip."
  else
    printf "No symlink to remove.\n"
  fi

  rm "$_tmp"

  if ! is_cli_mode || is_interactive_mode; then
    ask_remove_broken_symlinks
  elif is_cli_mode && [ "$_CHECK_BROKEN_SYMLINKS" = "true" ]; then
    remove_broken_symlinks
  fi

  return_menu
}

###############################################################################
# 5.2. Feature: Git
# Handle commit, push and pull from Dotig.
###############################################################################

# Commit only untracked files.
git_add_untracked_files() {
  verbose "Staging all untracked files..."

  if [ "$(get_untracked_files_count)" -gt 0 ]; then
    git -C "$_DOTIG_REPO" add "$(git -C "$_DOTIG_REPO" ls-files -o --exclude-standard)"
    verbose "$(success "All untracked files are staged.")"
  else
    printf "\nThere are no untracked files.\n"
  fi
}

# Commit only tracked files.
git_add_tracked_files() {
  verbose "Staging all changes in tracked files..."

  if [ "$(get_modified_files_count)" -gt 0 ] || [ "$(get_deleted_files_count)" -gt 0 ]; then
    git -C "$_DOTIG_REPO" add -u
    verbose "$(success "All changes in tracked files are staged.")"
  else
    printf "\nThere are no modified or deleted files.\n"
  fi
}

# Commit all changed and untracked files in Dotig repo.
git_add_all() {
  verbose "Staging all files in $(get_requested_env_var)..."
  git -C "$_DOTIG_REPO" add --all
  verbose "$(success "All files in $(get_requested_env_var) are staged.")"
}

# Create a Git commit using staged files.
# Argument 1 (optional): a commit message.
create_commit() {
  if [ $# -eq 0 ]; then
    git -C "$_DOTIG_REPO" commit
  elif [ $# -eq 1 ]; then
    local _commit_msg=$1
    if [ -n "$_commit_msg" ]; then
      git -C "$_DOTIG_REPO" commit -m "$_commit_msg"
    else
      invalid_usage "commit"
    fi
  else
    error_unexpected
  fi
}

# Commit all changes in the $DOTFILES repository.
# Argument 1 (optional): a commit message.
commit_changes() {
  [ $# -gt 1 ] && invalid_usage
  local _staged_files

  verbose "Creating a commit..."

  if [ "$_COMMIT_FILES" = "untracked" ]; then
    git_add_untracked_files
  elif [ "$_COMMIT_FILES" = "tracked" ]; then
    git_add_tracked_files
  else
    git_add_all
  fi

  _staged_files=$(get_staged_files_count) || true

  if [ "$_staged_files" -ne 0 ]; then
    printf "\n"
    create_commit "$@"
    success "Commit created!"
  else
    printf "\nCommit is not necessary, no staged files.\n"
  fi

  return_menu
}

# Push all unpushed commits in $DOTFILES repository.
push_changes() {
  local _unpushed_commits_count
  verbose "Checking for commit to push..."
  _unpushed_commits_count=$(get_unpushed_commits | wc -l)

  if [ "$_unpushed_commits_count" -ne 0 ]; then
    git -C "$_DOTIG_REPO" push
    printf "\n"
    success "Commit(s) pushed!"
  else
    printf "\nNothing to push.\n"
  fi

  return_menu
}

# Pull changes from remote repository.
pull_changes() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  verbose "Checking for changes in remote..."
  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if ! is_repo_up_to_date "$_local_commit" "$_remote_commit" && is_pull_needed "$_local_commit" "$_common_ancestor"; then
    if ! is_repo_dirty; then
      git -C "$_DOTIG_REPO" pull --rebase
      printf "\n"
      success "Repo is now up-to-date!"
    else
      printf "\n"
      warning "Dotig cannot pull. Your repo is dirty."
      printf "See the details below.\n"
      print_dirty_summary
      printf "Commit or stash (manually) your changes if you want to pull.\n"
    fi
  else
    printf "\nNothing to pull.\n"
  fi

  return_menu
}

# Update all Git submodules.
update_all_submodules() {
  verbose $'\nChecking for Git submodules...'
  if has_submodules; then
    verbose "Updating Git submodules..."
    update_submodules
    printf "\n"
    success "All submodules have been updated."
  else
    printf "No submodules found.\n"
  fi

  return_menu
}

###############################################################################
# 5.3. Feature: Repo Status
# Call git to obtain some info about the repo status and display these info.
###############################################################################

# Display the number of affected files foreach type of change.
print_dirty_summary() {
  local _untracked_files_count
  local _staged_files_count
  local _deleted_files_count
  local _renamed_files_count
  local _modified_files_count
  local _unmerged_files_count
  local _stashed_files_count
  local _expanded_status

  verbose "Counting changed files..."
  _untracked_files_count=$(get_untracked_files_count) || true
  _staged_files_count=$(get_staged_files_count) || true
  _deleted_files_count=$(get_deleted_files_count) || true
  _renamed_files_count=$(get_renamed_files_count) || true
  _modified_files_count=$(get_modified_files_count) || true
  _unmerged_files_count=$(get_unmerged_files_count) || true
  _stashed_files_count=$(get_stashed_count) || true

  _expanded_status="You have:\n"
  [ "$_untracked_files_count" -gt 0 ] && _expanded_status+="* $_untracked_files_count untracked files\n"
  [ "$_staged_files_count" -gt 0 ] && _expanded_status+="* $_staged_files_count staged files\n"
  [ "$_deleted_files_count" -gt 0 ] && _expanded_status+="* $_deleted_files_count deleted files\n"
  [ "$_renamed_files_count" -gt 0 ] && _expanded_status+="* $_renamed_files_count renamed files"
  [ "$_modified_files_count" -gt 0 ] && _expanded_status+="* $_modified_files_count modified files\n"
  [ "$_unmerged_files_count" -gt 0 ] && _expanded_status+="* $_unmerged_files_count unmerged files\n"
  [ "$_stashed_files_count" -gt 0 ] && _expanded_status+="* $_stashed_files_count stashed files\n"

  verbose "$(success "Changed files counted.")"
  printf "%b\n" "$_expanded_status"
}

# Display the list of changed files by category.
print_dirty_expanded() {
  verbose "Compiling the list of changed files..."

  if is_repo_dirty; then
    if [ "$(get_modified_files_count)" -ge 1 ]; then
      printf "\n%s modified files:\n" "$(get_modified_files_count)"
      highlight "$(git -C "$_DOTIG_REPO" ls-files -m)"
    fi
    if [ "$(get_untracked_files_count)" -ge 1 ]; then
      printf "\n%s untracked files:\n" "$(get_untracked_files_count)"
      highlight "$(git -C "$_DOTIG_REPO" ls-files -o)"
    fi
    if [ "$(get_deleted_files_count)" -ge 1 ]; then
      printf "\n%s deleted files:\n" "$(get_deleted_files_count)"
      highlight "$(git -C "$_DOTIG_REPO" ls-files -d)"
    fi
    if [ "$(get_renamed_files_count)" -ge 1 ]; then
      printf "\n%s renamed files.\n" "$(get_renamed_files_count)"
    fi
    if [ "$(get_unmerged_files_count)" -ge 1 ]; then
      printf "\n%s unmerged files:\n" "$(get_unmerged_files_count)"
      highlight "$(git -C "$_DOTIG_REPO" ls-files -u)"
    fi
    if [ "$(get_stashed_count)" -ge 1 ]; then
      printf "\n%s stashed files:\n" "$(get_stashed_count)"
      highlight "$(git -C "$_DOTIG_REPO" stash list)"
    fi
    if [ "$(get_staged_files_count)" -ge 1 ]; then
      printf "\n%s staged files:\n" "$(get_staged_files_count)"
      highlight "$(git -C "$_DOTIG_REPO" diff --name-only --cached)"
    fi

    verbose "$(success "List of changed files compiled.")"
  else
    printf "\nYou do not have any dirty files.\n"
  fi

  return_menu
}

# Display the repository status.
get_repo_status() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  verbose "Checking status..."
  printf "Your SSH passphrase can be requested.\n"
  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if is_repo_up_to_date "$_local_commit" "$_remote_commit"; then
    status -s "up-to-date!"
  else
    is_pull_needed "$_local_commit" "$_common_ancestor" && status -w "pull needed!"
    is_push_needed "$_remote_commit" "$_common_ancestor" && status -w "push needed!"
  fi

  if is_repo_dirty; then
    status -w "dirty repo!"
    if [ $_LIST_DIRTY = "true" ]; then
      print_dirty_expanded
    else
      print_dirty_summary
    fi
  else
    status -s "clean repo!"
  fi

  verbose "$(success "Status checked.")"
}

###############################################################################
# 5.4. Feature: Dotig Info
# Allow user to check current version of Dotig and to check for updates.
###############################################################################

# Display the version number of Dotig.
print_dotig_version() {
  verbose "Checking Dotig version..."
  printf "Your Dotig version is: %s\n" "$(highlight "$_DOTIG_VERSION")"
  verbose "$(success "Dotig version checked.")"
  return_menu
}

# Get a JSON object corresponding to the latest release.
get_latest_release() {
  curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/ArmandPhilippot/dotig/releases/latest
}

# Check if a new release exist by comparing the current version and the version
# of the latest release. If a new version exists, display a link to download it.
check_dotig_updates() {
  local _latest_release
  local _tag_name
  local _new_version
  local _download_zip
  local _download_link
  local _not_found

  verbose "Checking for Dotig updates..."
  verbose "Checking if curl is installed..."
  if ! is_command_installed "curl"; then
    printf "\n"
    error "curl is needed to check for Dotig update. Please install it."
    return_menu
  fi
  verbose "$(success "curl is installed.")"

  verbose "Obtaining latest Dotig release..."
  _latest_release=$(get_latest_release)
  _not_found=$(printf "%s" "$_latest_release" | { grep -Po '"message": "Not Found"' || true; })

  [ "$_not_found" ] && printf "\n" && error "Could not find any release..." && return_menu
  verbose "$(success "Latest release obtained.")"

  _tag_name=$(printf "%s" "$_latest_release" | grep -Po '"tag_name":.*?[^\\]",')
  _new_version=$(printf "%s" "$_tag_name" | grep -Po '(?=v).*(?=",)' | sed 's/^v//')

  if [ "$_new_version" = "$_DOTIG_VERSION" ]; then
    success "Your Dotig version is up to date!"
  else
    _download_zip=$(printf "%s" "$_latest_release" | grep -Po '"zipball_url":.*?[^\\]",')
    _download_link=$(printf "%s" "$_download_zip" | grep -Po 'http.*(?=",)')

    warning "Your Dotig version is outdated!"
    printf "A new version is available: %s\n" "$(highlight "$_new_version")"
    printf "You can download it here: %s\n" "$(highlight "$_download_link")"
  fi

  return_menu
}

###############################################################################
# 6. Help Menus
# Functions to print the various help menus.
###############################################################################

# Display the main help menu.
print_dotig_help() {
  cat <<EOF
# USAGE
dotig [OPTIONS]
dotig <COMMANDS> [OPTIONS] [<FILES...>]

# DESCRIPTION
Dotig is a dotfiles manager to quickly setup your machine & synchronize your dotfiles with Git.

# COMMANDS
add                 Add new dotfiles and create symlinks.
                    Accept both absolute and relative paths.
update              Update all symlinks.
commit              Use Git to commit all changes.
push                Use Git to push all changes.
pull                Use Git to pull changes from remote.
submodule           Update Git submodules.
rm                  Replace all symlinks with the original file.
                    The original will be conserved in your repository.
status              Display the status of your dotfiles repository.
                    Check for dirty files and if push or pull is needed.
version             Print Dotig version and check for a new release.

# OPTIONS
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-h, --help          Print this help. If used after a command, you can print help
                    for this command.
-s, --status        Print a summary of the repo status before Dotig menu.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# CONFIGURATION
DOTFILES            Environment variable to define the path of your dotfiles
                    repository.
                    Current value: $DOTFILES
DOTFILES_PRIVATE    Environment variable to define the path of your private
                    dotfiles repository.
                    Current value: $DOTFILES_PRIVATE

You need to declare these values in your shell configuration files. For example in .profile for Bash or .zshenv for Zsh.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version             Dotig $_DOTIG_VERSION
License             MIT
Project URL         https://github.com/ArmandPhilippot/dotig
EOF

  return_menu
}

# Display the help for add command then exit.
print_add_help() {
  cat <<EOF
# USAGE
dotig add [OPTIONS] [<FILES...>]

# DESCRIPTION
The add command allows Dotig to copy your dotfiles inside your backup directory then to symlink them. You can provide one or more files. If it is a directory, the files inside will be processed.

# OPTIONS
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-h, --help          Print this help.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for update command then exit.
print_update_help() {
  cat <<EOF
# USAGE
dotig update [OPTIONS]

# DESCRIPTION
The update command allows Dotig to create or update all the symlinks based on your backup dotfiles. This command also removes all the broken symlinks in your \$HOME if the symlink target is in your repo.
It only handles files in home directory. If your repo contains files outside your \$HOME you need to create the symlinks yourself.

# OPTIONS
-a, --all                 Check for broken symlinks and ask user how to handle
                          conflicts instead of skipping. You can achieve the
                          same thing by combining the following options: -b, -d
                          and -t.
-b, --broken-symlinks     Also check for broken symlinks. If any, remove them.
-d, --duplicate           If a file with the same name exists but it is not a
                          symlink, ask user how to handle conflict instead of
                          skipping.
-i, --interactive         Interactive mode. Helpful to configure your dotfiles
                          repo if it is the first time or to print additional
                          dialogs.
-h, --help                Print this help.
-p, --private             Use your private dotfiles repository instead of the
                          default.
-t, --target              If a symlink already exists but its target does not
                          match the backup file, ask user how to handle
                          conflict instead of skipping.
-v, --verbose             Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for commit command then exit.
print_commit_help() {
  cat <<EOF
# USAGE
dotig commit [OPTIONS]

# DESCRIPTION
The commit command allows Dotig to staged all changes in your repository (untracked, modified, renamed files for example) then to call the Git commit command. Then, you will be able to enter a commit message.

# OPTIONS
-h, --help          Print this help.
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-m, --message       Use the given string as commit message. If used with another
                    option, the message must follow the -m or --message option.
-p, --private       Use your private dotfiles repository instead of the default.
-t, --tracked       Commit only tracked files. Ignore untracked.
-u, --untracked     Commit only untracked files. Ignore others (i.e. modified or
                    deleted).
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for push command then exit.
print_push_help() {
  cat <<EOF
# USAGE
dotig push [OPTIONS]

# DESCRIPTION
The push command allows Dotig to push all the commits to your remote repository. If Dotig cannot find new commits, it will print that push is not necessary.

# OPTIONS
-h, --help          Print this help.
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for pull command then exit.
print_pull_help() {
  cat <<EOF
# USAGE
dotig pull [OPTIONS]

# DESCRIPTION
The pull command allows Dotig to fetch your remote repository then to merge all incoming changes inside your local repository using the Git rebase strategy. If Dotig cannot find new remote changes, it will print that pull is not necessary.

# OPTIONS
-h, --help          Print this help.
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for submodule command then exit.
print_submodule_help() {
  cat <<EOF
# USAGE
dotig submodule [OPTIONS]

# DESCRIPTION
If you are using git submodules inside your dotfiles repository, the submodule command allows Dotig to update all of them.

# OPTIONS
-h, --help          Print this help.
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for remove command then exit.
print_remove_help() {
  cat <<EOF
# USAGE
dotig rm [OPTIONS]

# DESCRIPTION
The rm command allows Dotig to replace all the symlinks in your \$HOME whose target is in your repository with the original file. The file insde your repository will be kept.

# OPTIONS
-h, --help                Print this help.
-i, --interactive         Interactive mode. Helpful to configure your dotfiles
                          repo if it is the first time or to print additional
                          dialogs.
-p, --private             Use your private dotfiles repository instead.
-v, --verbose             Explain what is done.
-b, --broken-symlinks     Also remove broken symlinks.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for status command then exit.
print_status_help() {
  cat <<EOF
# USAGE
dotig status [OPTIONS]

# DESCRIPTION
The status command allows Dotig to display information about your repository status. It will check if your repository is up to date and clean.
This command will tell you if you need to pull or push changes. If your repository is dirty it will also print some information to help you know why by displaying the number of modified, staged, removed or untracked files.

# OPTIONS
-e, --expanded      If your local repository is dirty, print the concerned files
                    by category (i.e. modified files, deleted files...).
-h, --help          Print this help.
-i, --interactive   Interactive mode. Helpful to configure your dotfiles repo
                    if it is the first time or to print additional dialogs.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for version command then exit.
print_version_help() {
  cat <<EOF
# USAGE
dotig version [OPTIONS]

# DESCRIPTION
The version command allows Dotig to print its version and to check for a new release.

# OPTIONS
-h, --help          Print this help.
-v, --verbose       Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $_DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

###############################################################################
# 7. Main Menu
# Display all possible options.
###############################################################################

# Display the list of choices available in the main menu of Dotig.
print_menu_options() {
  printf "Choose an action to perform:\n"
  printf "[%s] Add dotfile(s) to your repo\n" "$(option "1")"
  printf "[%s] Update symlinks\n" "$(option "2")"
  printf "[%s] Commit dotfiles changes\n" "$(option "3")"
  printf "[%s] Push changes to remote\n" "$(option "4")"
  printf "[%s] Pull changes from remote\n" "$(option "5")"
  printf "[%s] Update all Git submodules\n" "$(option "6")"
  printf "[%s] Remove all symlinks\n" "$(option "7")"
  printf "[%s] Print the dirty files list\n" "$(option "8")"
  printf "[%s] Check for Dotig update\n" "$(option "9")"
  printf "[%s] Print Dotig version\n" "$(option "10")"
  printf "[%s] Print Dotig help\n" "$(option "11")"
  printf "[%s] Exit\n" "$(option "q")"
}

# Display the main menu of Dotig.
print_menu() {
  local _choice

  while true; do
    print_menu_options
    printf "Your choice: "
    read -r _choice

    case $_choice in
    1) add_dotfiles ;;
    2) update_symlinks ;;
    3) commit_changes ;;
    4) push_changes ;;
    5) pull_changes ;;
    6) update_all_submodules ;;
    7) remove_symlinks ;;
    8) print_dirty_expanded ;;
    9) check_dotig_updates ;;
    10) print_dotig_version ;;
    11) print_dotig_help ;;
    [qQ]) exit ;;
    *) error $'Invalid choice. Try again.\n' ;;
    esac
  done
}

# Ask user if he wants to return to the menu or exit Dotig.
return_menu() {
  [ $_DISABLE_MENU = "true" ] && return

  local _choice

  while true; do
    printf "\nWhat do you want to do: return to the menu [%s] or quit [%s]? " "$(option "r")" "$(option "q")"
    read -r _choice

    case $_choice in
    [rR]) return ;;
    [qQ]) exit ;;
    *)
      printf "\n"
      error "Invalid choice. Please enter $(option "r") (return) or $(option "q") (quit)."
      ;;
    esac
  done
}

# Execute all necessary check/config before printing the menu.
launch_dotig_menu() {
  print_logo
  check_requirements
  init_dotfiles_repo
  set_xdg_paths
  [ $_REPO_STATUS = "true" ] && get_repo_status
  print_menu
}

###############################################################################
# 8. CLI
# Handle the command line interface scenario.
###############################################################################

# Handle options for the add dotfiles command before calling it.
launch_add_dotfiles() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "add"
    print_add_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) break ;;
    esac
  done

  init_dotfiles_repo
  add_dotfiles "$@"
}

# Handle options for the update symlinks command before calling it.
launch_update_symlinks() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "update"
    print_update_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --all | -a)
      _CHECK_BROKEN_SYMLINKS="true"
      _SKIP_DUPLICATE="false"
      _SKIP_TARGET="false"
      shift
      ;;
    --broken-symlinks | -b)
      _CHECK_BROKEN_SYMLINKS="true"
      shift
      ;;
    --duplicate | -d)
      _SKIP_DUPLICATE="false"
      shift
      ;;
    --interactive | -i)
      set_interactive_default_parameters
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --target | -t)
      _SKIP_TARGET="false"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "update" ;;
    esac
  done

  init_dotfiles_repo
  update_symlinks
}

# Handle options for the commit changes command before calling it.
launch_commit_changes() {
  local _commit_message

  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "commit"
    print_commit_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --message | -m)
      shift
      _commit_message="$1"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --tracked | -t)
      _COMMIT_FILES="tracked"
      shift
      ;;
    --untracked | -u)
      _COMMIT_FILES="untracked"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "commit" ;;
    esac
  done

  init_dotfiles_repo

  if [ -n "$_commit_message" ]; then
    commit_changes "$_commit_message"
  else
    commit_changes
  fi
}

# Handle options for the push changes command before calling it.
launch_push_changes() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "push"
    print_push_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "push" ;;
    esac
  done

  init_dotfiles_repo
  push_changes
}

# Handle options for the pull changes command before calling it.
launch_pull_changes() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "pull"
    print_pull_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "pull" ;;
    esac
  done

  init_dotfiles_repo
  pull_changes
}

# Handle options for the update submodules command before calling it.
launch_update_all_submodules() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "submodule"
    print_submodule_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "submodule" ;;
    esac
  done

  init_dotfiles_repo
  update_all_submodules
}

# Handle options for the remove symlinks command before calling it.
launch_remove_symlinks() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "rm"
    print_remove_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --broken-symlinks | -b)
      _CHECK_BROKEN_SYMLINKS="true"
      shift
      ;;
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "rm" ;;
    esac
  done

  init_dotfiles_repo
  remove_symlinks
}

# Handle options for the get repo status command before calling it.
launch_get_repo_status() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "status"
    print_status_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --expanded | -e)
      _LIST_DIRTY="true"
      shift
      ;;
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "status" ;;
    esac
  done

  init_dotfiles_repo
  get_repo_status
}

# Handle options version command then execute functions.
launch_dotig_version() {
  if is_help_option "$1"; then
    [ $# -gt 1 ] && invalid_usage "version"
    print_version_help
    exit
  fi

  while [ $# -ge 1 ]; do
    case $1 in
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *) invalid_usage "version" ;;
    esac
  done

  print_logo
  print_dotig_version
  check_dotig_updates
}

# Redirect provided command to the right function.
# Require 1 or more arguments.
# Argument 1: a valid command.
set_command() {
  [ $# -eq 0 ] && error_unexpected

  local _command_name=$1
  shift

  set_xdg_paths
  set_cli_default_parameters

  case $_command_name in
  add) launch_add_dotfiles "$@" ;;
  update) launch_update_symlinks "$@" ;;
  commit) launch_commit_changes "$@" ;;
  push) launch_push_changes "$@" ;;
  pull) launch_pull_changes "$@" ;;
  submodule) launch_update_all_submodules "$@" ;;
  rm) launch_remove_symlinks "$@" ;;
  status) launch_get_repo_status "$@" ;;
  version) launch_dotig_version "$@" ;;
  *) error_unexpected ;;
  esac

  exit
}

# Set Dotig options according to the provided arguments.
# Require at least one argument. Additional arguments can be valid.
set_options() {
  [ $# -eq 0 ] && error_unexpected

  while [ $# -ge 1 ]; do
    case $1 in
    --help | -h)
      [ $# -gt 1 ] && invalid_usage
      _DISABLE_MENU="true"
      print_dotig_help
      exit
      ;;
    --interactive | -i)
      _INTERACTIVE_MODE="true"
      shift
      ;;
    --status | -s)
      _REPO_STATUS="true"
      shift
      ;;
    --private | -p)
      _PRIVATE_REPO="true"
      shift
      ;;
    --verbose | -v)
      _VERBOSE="true"
      shift
      ;;
    *)
      if is_dotig_cli_command "$1"; then
        set_command "$@"
      else
        invalid_usage
      fi
      ;;
    esac
  done

  launch_dotig_menu
}

###############################################################################
# 9. Entry Point
# Main entry point of Dotig.
###############################################################################

main() {
  if [ $# -eq 0 ]; then
    launch_dotig_menu
  elif is_dotig_cli_command "$1"; then
    set_command "$@"
  else
    set_options "$@"
  fi
}

###############################################################################
# 10. Execute Dotig
###############################################################################

main "$@"
