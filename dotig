#!/usr/bin/env bash
#
# Dotig
# A dotfiles manager to quickly setup your machine & synchronize your dotfiles
# with Git.
#
# Requirements: Git, GNU/Linux, GNU Coreutils and curl.
# Tested with: Manjaro 21, Debian 10, Ubuntu 20 and Fedora 34.
# Author: Armand Philippot <https://www.armandphilippot.com/>
# URL: https://github.com/ArmandPhilippot/dotig

###############################################################################
#
# The MIT License (MIT)

# Copyright (c) 2021 Armand Philippot

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
###############################################################################

set -e

###############################################################################
# TABLE OF CONTENT
# ================
# 1. Variables
#   1.1. Globals
#   1.2. Colors
#   1.3. Parameters
# 2. Helpers
#   2.1. Miscelleanous Helpers
#   2.2. Parameters & Arguments Helpers
#   2.3. Colors Helpers
#   2.4. Paths Helpers
#   2.5. Error Helpers
#   2.6. Git Helpers
# 3. Safety Checks
# 4. Repo Configuration
# 5. Dotig Features
#   5.1. Feature: Dotfiles Symlinks
#   5.2. Feature: Git
#   5.3. Feature: Repo Status
#   5.4. Feature: Dotig Info
# 6. Help Menus
# 7. Main Menu
# 8. Entry Point
# 9. CLI
# 10. Execute Dotig
###############################################################################

###############################################################################
# 1. Variables
###############################################################################

###############################################################################
# 1.1. Globals
###############################################################################
DOTIG_COMMANDS=("add" "update" "commit" "push" "pull" "submodule" "rm" "status")
DOTIG_LOGO=$(
  cat <<-EOF
#######################################
##      ____        _   _            ##
##     |  _ \  ___ | |_(_) __ _      ##
##     | | | |/ _ \| __| |/ _  |     ##
##     | |_| | (_) | |_| | (_| |     ##
##     |____/ \___/ \__|_|\__, |     ##
##                        |___/      ##
##                                   ##
#######################################
EOF
)
DOTIG_PATH=""
DOTIG_VERSION="1.2.2"

###############################################################################
# 1.2. Colors
###############################################################################
_color_blue=$(printf '\e[34m')
_color_red=$(printf '\e[31m')
_color_magenta=$(printf '\e[35m')
_color_reset=$(printf '\e[0m')
_color_green=$(printf '\e[32m')
_color_yellow=$(printf '\e[33m')

###############################################################################
# 1.3. Parameters
###############################################################################
# Globals parameters
_disable_menu="false"
_show_repo_status="true"
_verbose="false"
_private_dotfiles="false"

# Update symlinks parameters
_ignore_duplicate="false"
_ignore_symlink_different_target="false"

# Status parameters
_show_dirty_filenames="false"

# Commit parameters
_commit_files="all"

###############################################################################
# 2. Helpers
# Various helpers used across the script in different locations.
###############################################################################

###############################################################################
# 2.1. Miscelleanous Helpers
###############################################################################

# Print Dotig logo
print_logo() {
  printf "%s\n\n" "$DOTIG_LOGO"
}

# Check if the current OS is GNU/Linux.
is_linux() {
  [ "$OSTYPE" = "linux-gnu" ]
}

# Check if Git is installed.
is_git_installed() {
  [ -x "$(command -v git)" ]
}

# Check if curl is installed.
is_curl_installed() {
  [ -x "$(command -v curl)" ]
}

###############################################################################
# 2.2. Parameters & Arguments Helpers
# Functions to handle Dotig parameters/arguments.
###############################################################################

# Check if verbose mode is activated.
is_verbose() {
  [ "$_verbose" = "true" ]
}

# Check if the first argument provided is an available command.
# Argument 1: the command to test.
is_dotig_cli_command() {
  for _command in "${DOTIG_COMMANDS[@]}"; do
    [ "$1" = "$_command" ] && return 0
  done
  return 1
}

# Check if the argument passed is the help option.
# Argument 1: the option to test.
is_command_help() {
  [ $# -ne 1 ] && error_unexpected

  [ "$1" = "-h" ] || [ "$1" = "--help" ]
}

###############################################################################
# 2.3. Colors Helpers
# Functions to print some messages in color.
###############################################################################

option() {
  printf "%s%s%s" "$_color_blue" "$1" "$_color_reset"
}

highlight() {
  printf "%s%s%s" "$_color_magenta" "$1" "$_color_reset"
}

error() {
  printf "%sError:%s %s\n" "$_color_red" "$_color_reset" "$1"
}

success() {
  printf "%sSuccess:%s %s\n" "$_color_green" "$_color_reset" "$1"
}

warning() {
  printf "%sWarning:%s %s\n" "$_color_yellow" "$_color_reset" "$1"
}

skipped() {
  printf "%sSkipped:%s %s\n" "$_color_yellow" "$_color_reset" "$1"
}

status() {
  local _option=$1
  local _msg=$2
  local _status_color

  case $_option in
  -s) _status_color=$_color_green ;;
  -w) _status_color=$_color_yellow ;;
  esac

  printf "Status: %s%s%s\n" "$_status_color" "$_msg" "$_color_reset"
}

###############################################################################
# 2.4. Paths Helpers
# Various functions to handle paths (set, normalize, convert...).
###############################################################################

# Return the absolute path.
# Argument 1: a path to convert. Also used to store the absolute path.
get_absolute_path() {
  [ $# -ne 1 ] && error_unexpected

  local -n _file=$1
  local _absolute_path

  case $_file in
  /*) _absolute_path=$_file ;;
  \~/*) _absolute_path="$HOME/${_file:2}" ;;
  ./*) _absolute_path="$(pwd)/${_file:2}" ;;
  *) _absolute_path="$(pwd)/$_file" ;;
  esac

  eval "$1=$_absolute_path"
}

# Prompt user to define an existing directory path.
# Return the entered path.
set_path() {
  local _path
  printf "Set the path: " >&2
  read -r -e _path
  get_absolute_path _path

  while [ ! -d "$_path" ]; do
    error "$(highlight "$_path") is not a directory."
    printf "Please enter a valid path: "
    read -r -e _path
    get_absolute_path _path
  done

  case $_path in
  */) : ;;
  *) _path="${_path}/" ;;
  esac

  eval "$1=$_path"
}

# Ask user if the provided path is correct, if not define new path.
# Argument 1: the path to test. Also used to store the path.
# Return the path (the new one or preserve the previous one).
is_correct_path() {
  [ $# -ne 1 ] && error_unexpected

  local _validation
  local -n _valid_path=$1

  while true; do
    printf "Is %s correct? [$(option "y")/$(option "n")]" "$(highlight "$_valid_path")"
    read -r _validation
    case $_validation in
    [yY])
      break
      ;;
    [nN])
      set_path _valid_path
      ;;
    *) error "Please enter $(option "y") (yes) or $(option "n") (no)." ;;
    esac
  done
}

# Check if a file is in the provided path.
# Argument 1: the file to test
# Argument 2: the path
is_file_in() {
  [ $# -ne 2 ] && error_unexpected

  local _file=$1
  local _tested_path=$2

  case $_file in
  "$_tested_path"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Check if the provided path is an existent directory.
# Argument 1: the path to test
is_valid_backup_path() {
  local _valid_backup_path=$1

  [ ! "$_valid_backup_path" ] && error_backup_path
  [ ! -d "$_valid_backup_path" ] && error_backup_path
  return 0
}

# Add a trailing slash to the path if it is missing.
normalize_dotig_path() {
  case $DOTIG_PATH in
  */) : ;;
  *) DOTIG_PATH="${DOTIG_PATH}/" ;;
  esac
}

# Set DOTIG_PATH with the correct format.
# Argument 1: the path to use for DOTIG_PATH
set_dotig_path() {
  [ $# -ne 1 ] && error_unexpected

  local _tmp_path=$1

  get_absolute_path _tmp_path
  is_valid_backup_path "$_tmp_path" && DOTIG_PATH=$_tmp_path
  normalize_dotig_path
}

# Use XDG Spefication to handle dotfiles and symlinks.
# Check if XDG path are set, if not set them.
set_xdg_paths() {
  if is_linux; then
    XDG_BIN_HOME=${XDG_BIN_HOME:-$HOME/.local/bin}
    XDG_CACHE_HOME=${XDG_CACHE_HOME:-$HOME/.cache}
    XDG_CONFIG_HOME=${XDG_CONFIG_HOME:-$HOME/.config}
    XDG_DATA_HOME=${XDG_DATA_HOME:-$HOME/.local/share}
    XDG_LIB_HOME=${XDG_LIB_HOME:-$HOME/.local/lib}
    XDG_STATE_HOME=${XDG_STATE_HOME:-$HOME/.local/state}
  else
    error "Only Linux is supported."
    exit 2
  fi
}

###############################################################################
# 2.5. Error Helpers
# Functions to handle the various error messages.
###############################################################################

# Clean up temporary files then exit.
cleanup() {
  is_verbose && printf "\n\nDeleting temporary files...\n"
  rm -f "$_tmp"
  if is_verbose; then
    success "Temporary files deleted."
    printf "Exit.\n"
  fi
  exit
}

# Display an error in case of an unplanned scenario then exit.
error_unexpected() {
  error "An unexpected error occurred."
  printf "Exit.\n"
  cleanup
  exit 1
}

# Display an error in case of invalid usage then exist.
invalid_usage() {
  error "Invalid usage."

  if [ $# -eq 1 ]; then
    local _command_name=$1

    printf "Use \`dotig %s --help\` or \`dotig %s -h\` to display all accepted options.\n" "$_command_name" "$_command_name"
  else
    printf "Use \`dotig --help\` or \`dotig -h\` to display all accepted commands and options.\n"
  fi

  exit 1
}

# Display an error if the dotfiles repository is not defined then exit.
error_backup_path() {
  local _env_var

  if [ "$_private_dotfiles" = "true" ]; then
    _env_var="\$DOTFILES_PRIVATE"
  else
    _env_var="\$DOTFILES"
  fi

  error "$(highlight "$_env_var") must be set to use Dotig command line interface."
  printf "See CONFIGURATION in \`dotig --help\` or \`dotig -h\`.\n"
  exit 1
}

# Execute cleanup function if these signals are caught.
trap cleanup SIGHUP SIGINT SIGQUIT SIGTERM

###############################################################################
# 2.6. Git Helpers
# Git specific helpers used in different locations across the script.
###############################################################################

# Return the branch name on which the working tree is on.
get_current_branch() {
  git -C "$DOTIG_PATH" symbolic-ref --quiet --short HEAD
}

# Return the upstream name for the current branch.
get_upstream_name() {
  local _git_branch
  _git_branch=$(get_current_branch)
  git -C "$DOTIG_PATH" config branch."$_git_branch".remote 2>/dev/null
}

# Get the remote branch name of the current repository.
get_remote_branch() {
  git -C "$DOTIG_PATH" ls-remote --symref origin HEAD | head -1 | sed 's@ref: refs/heads/@@' | cut -f1
}

# Return a list of existing Git remotes.
get_existing_remotes() {
  git -C "$DOTIG_PATH" remote
}

# Download objects and refs from remote.
fetch_remote() {
  git -C "$DOTIG_PATH" fetch
}

# Return the object name of the current commit on the working tree.
get_local_commit() {
  git -C "$DOTIG_PATH" rev-parse --verify -q HEAD
}

# Check if the local repo has at least one commit.
has_local_commit() {
  local _commit_count
  _commit_count=$(get_local_commit | wc -l) || true
  [ "$_commit_count" -ge 1 ]
}

# Return the object name of the last commit on the remote.
get_remote_commit() {
  git -C "$DOTIG_PATH" rev-parse --verify -q FETCH_HEAD
}

# Return a good common ancestor if the working tree has at least one commit.
get_common_ancestor() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" ] && git -C "$DOTIG_PATH" merge-base HEAD "$_remote_commit"
}

# Check if the current commit and the last commit on the remote are the same.
is_repo_up_to_date() {
  local _local_commit=$1
  local _remote_commit=$2

  [ "$_local_commit" = "$_remote_commit" ]
}

# Check if the remote is ahead the working tree.
is_pull_needed() {
  local _local_commit=$1
  local _common_ancestor=$2

  [ "$_local_commit" = "$_common_ancestor" ]
}

# Check if the remote is behind the working tree.
is_push_needed() {
  local _remote_commit=$1
  local _common_ancestor=$2

  [ "$_remote_commit" = "$_common_ancestor" ]
}

# Return the number of changed files (modified, deleted...) on the working tree.
get_dirty_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | wc -l
}

# Check if the working tree has changed files.
is_repo_dirty() {
  local _dirty_files_count
  _dirty_files_count=$(get_dirty_files_count)

  [ "$_dirty_files_count" -ne 0 ]
}

# Return the number of untracked files.
get_untracked_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^??"
}

# Return the number of staged files.
get_staged_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^[A|M]"
}

# Return the number of deleted files.
get_deleted_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^.D"
}

# Return the number of renamed files.
get_renamed_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^R"
}

# Return the number of modified files.
get_modified_files_count() {
  git -C "$DOTIG_PATH" status --porcelain | grep -c "^.M"
}

# Return the number of unmerged files.
get_unmerged_files_count() {
  git -C "$DOTIG_PATH" ls-files --unmerged | wc -l
}

# Return the number of stash.
get_stashed_count() {
  git -C "$DOTIG_PATH" stash list | wc -l
}

# Return the list of unpushed commits.
get_unpushed_commits() {
  local _remote
  local _branch

  _remote=$(get_upstream_name)
  _branch=$(get_current_branch)

  has_local_commit && git -C "$DOTIG_PATH" log --oneline "$_remote"/"$_branch"..HEAD
}

# Check if the repo has Git submodules.
has_submodules() {
  local _tmp
  local _submodules

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  git -C "$DOTIG_PATH" submodule status >"$_tmp"

  while IFS='' read -r line; do _submodules+=("$line"); done <"$_tmp"

  rm "$_tmp"

  [ "${#_submodules[@]}" -gt 0 ]
}

# Update all the Git submodules.
update_submodules() {
  git -C "$DOTIG_PATH" submodule update --init --recursive
}

# Return a list of Git submodule paths.
get_submodules_path() {
  # shellcheck disable=SC2016
  git -C "$DOTIG_PATH" submodule -q foreach 'printf ${sm_path}"\n"'
}

# Check if the dotfiles backup directory is a Git repository.
is_git_repo() {
  git -C "$DOTIG_PATH" rev-parse --git-dir >/dev/null 2>&1
}

# Check if the remote is set.
is_remote_set() {
  git -C "$DOTIG_PATH" config --get-regexp '^remote\.' >/dev/null 2>&1
}

# Check if the provided remote name exists.
# Argument 1: the remote to test.
# Argument 2: a list of existing remotes.
is_valid_remote_name() {
  [ $# -ne 2 ] && error_unexpected

  case $2 in
  *"$1"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Check if the provided remote URL is a supported URL.
# Argument 1: the URL to test.
is_valid_remote_url() {
  [ $# -ne 1 ] && error_unexpected

  local _remote_url=$1

  case $_remote_url in
  "https"* | "git@"*) return 0 ;;
  *) return 1 ;;
  esac
}

# Check if the provided URL is an existing remote.
# Argument 1: the URL to test.
is_existing_remote() {
  local _remote=$1

  git ls-remote "$_remote" >/dev/null 2>&1
}

###############################################################################
# 3. Safety Checks
# Do not execute Dotig if operating system is not supported or if Git is not
# installed.
###############################################################################

# Check for supported OS/distribution.
check_os() {
  is_verbose && printf "Identifying the operating system...\n"

  if is_linux; then
    if is_verbose; then
      success "Linux is supported."
    fi
  else
    error "Linux is the only supported operating system."
    printf "Exit.\n"
    exit 1
  fi
}

# Check if the commands required by the script are available.
check_commands() {
  is_verbose && printf "Checking installed programs...\n"

  if is_git_installed; then
    if is_verbose; then
      success "Git is installed."
    fi
  else
    error "Dotig needs Git to function properly."
    printf "Please install it before using this program.\n"
    printf "Exit.\n"
    exit 1
  fi

  if is_curl_installed; then
    if is_verbose; then
      success "curl is installed."
    fi
  else
    warning "curl is needed to check for Dotig update. Please install it if you want to use this feature."
  fi
}

# Check if all the requirements are filled.
check_requirements() {
  is_verbose && printf "Checking requirements...\n"
  check_os
  check_commands
  if is_verbose; then
    success "Requirements checked!"
    printf "Let's continue.\n\n"
  fi
}

###############################################################################
# 4. Repo Configuration
# Check if $DOTFILES is defined and if it is a repo. If not, set both.
###############################################################################

# Check if $DOTFILES is set and contains the correct backup path, if not set it.
# Require 1 argument to store the path.
# Return the path to use.
check_backup_path() {
  local _backup_path
  local _dotfiles_path

  is_verbose && printf "For conveniance, Dotig uses a \$DOTFILES variable to determine the dotfiles backup path and a \$DOTFILES_PRIVATE variable to determine your private dotfiles.\n"
  is_verbose && printf "If they are not set, you may want to declare them for future use.\n\n"
  printf "Checking if your dotfiles repository is set in your shell...\n"

  if [ "$_private_dotfiles" = "true" ]; then
    _dotfiles_path=$DOTFILES_PRIVATE
  else
    _dotfiles_path=$DOTFILES
  fi

  if [ ! "$_dotfiles_path" ]; then
    warning "You did not define your dotfiles repository in your shell configuration files."
    set_path _backup_path
    is_correct_path _backup_path
  elif [ ! -d "$_dotfiles_path" ]; then
    warning "The path provided in your shell configuration files does not seem to match a directory."
    set_path _backup_path
    is_correct_path _backup_path
  else
    is_verbose && success "Dotfiles repository found."
    _backup_path=$_dotfiles_path
    is_correct_path _backup_path
  fi

  eval "$1=$_backup_path"
}

# Ask the remote name when multiple remotes exist.
# Require 1 argument to store the remote name.
# Return the remote name.
ask_remote_name() {
  local _git_remotes
  local _current_branch
  local _choice

  _git_remotes=$(get_existing_remotes)
  _current_branch=$(get_current_branch)

  warning "Your repo contains multiple remotes:"
  printf "%s\n" "$_git_remotes"
  printf "Choose the remote to use for %s: " "$(highlight "$_current_branch")"
  read -r _choice

  while ! is_valid_remote_name "$_choice" "$_git_remotes"; do
    error "Remote name invalid."
    printf "Use one of:\n"
    printf "%s\n" "$(option "$_git_remotes")"
    printf "Enter a valid remote name: "
    read -r _choice
  done

  printf "\n"

  eval "$1=$_choice"
}

# Define the upstream branch and update the local repo.
set_upstream_branch() {
  local _git_remotes
  local _remote_name
  local _remote_branch

  _git_remotes=$(get_existing_remotes)

  if [ "$(printf "%s\n" "$_git_remotes" | wc -l)" -gt 1 ]; then
    ask_remote_name _remote_name
  else
    _remote_name=$_git_remotes
  fi

  _remote_branch=$(get_remote_branch)

  git -C "$DOTIG_PATH" fetch "$_remote_name"
  git -C "$DOTIG_PATH" checkout -t "$_remote_name"/"$_remote_branch"

  if is_verbose; then
    success "Upstream set."
  fi
}

# Check if the upstream branch is set, if not define it.
check_upstream() {
  if ! get_upstream_name; then
    set_upstream_branch
  fi
}

# Check if the provided remote URL is a remote repository.
# Argument 1: the URL to test.
is_valid_remote() {
  [ $# -ne 1 ] && error_unexpected

  local -n _valid_remote=$1

  if [ -n "$_valid_remote" ]; then
    ! is_valid_remote_url "$_valid_remote" && printf "\n" && error "The remote URL is not valid. URL must starts with $(highlight "https") or $(highlight "git@")." && return 1

    printf "\nChecking if this URL exists. Your SSH passphrase can be requested.\n"

    ! is_existing_remote "$_valid_remote" && error "This remote URL does not exist." && return 1

    return 0
  else
    return 1
  fi
}

# Define the remote repository.
set_remote() {
  local _remote

  printf "\nDotig needs to know your remote to perform some actions (status, push, pull).\n"

  while ! is_valid_remote _remote; do
    printf "Please enter your remote address: "
    read -r _remote
  done

  git -C "$DOTIG_PATH" remote add origin "$_remote"

  if is_verbose; then
    success "Remote set."
  fi
}

# Check if the remote repository is set, if not define it.
check_remote() {
  if ! is_remote_set; then
    if is_verbose; then
      printf "\n"
      warning "Dotig is a Git repository but the remote is not set."
      printf "\n"
    fi
    set_remote
  fi
}

# Initialize the Git submodules.
init_submodules() {
  if has_submodules; then
    if is_verbose; then
      printf "Init submodules...\n"
    fi

    update_submodules

    if is_verbose; then
      success "All submodules have been initialized and updated."
    fi
  fi
}

# Initialize a new Git repository with remote, upstream and submodules.
init_git() {
  git -C "$DOTIG_PATH" init
  set_remote
  set_upstream_branch
  init_submodules
}

# Ask user if he wants to set the git repo then init git or exit.
set_git_repo() {
  printf "\n"
  warning "Your dotfiles directory is not a Git repository."

  while true; do
    printf "Do you want to configure it? [%s/%s] " "$(option "y")" "$(option "n")"
    read -r _choice

    case $_choice in
    [yY])
      init_git
      return 0
      ;;
    [nN])
      printf "\n"
      warning "Dotig needs a Git repository to properly function. Please configure it manually before using this program."
      printf "Exit.\n"
      exit
      ;;
    *) error "Enter $(option "y") (yes) or $(option "n") (no)." ;;
    esac
  done
}

# Check if the Git repository is ready, if not complete the configuration.
check_git_configuration() {
  local _choice

  is_verbose && printf "\nChecking if Git is configured...\n"

  if ! is_git_repo; then
    set_git_repo
  else
    check_remote
    check_upstream
  fi
}

# Check if the dotfiles path is set and if it is a Git repository, if not
# configure it.
is_backup_repo_ready() {
  check_backup_path DOTIG_PATH
  set_dotig_path "$DOTIG_PATH"
  check_git_configuration
  success "Your dotfiles repo is ready."
}

###############################################################################
# 5. Dotig Features
###############################################################################

###############################################################################
# 5.1. Feature: Dotfiles Symlinks
# Handle dotfiles backup and symlinks update/removal.
###############################################################################

# Display the diff between two files.
# Argument 1: the file residing in $HOME.
# Argument 2: the file residing in $DOTFILES.
print_diff() {
  local _home_dotfile=$1
  local _backup_dotfile=$2
  local _filename
  local _column_width
  local _padding
  local _padding_lenght
  local _divider

  [ ! $COLUMNS ] && COLUMNS=$(stty size | awk '{print $2}')
  _column_width=$(("$COLUMNS" / 2))
  _filename=$(basename "$_home_dotfile")
  _padding=$(printf '%*s' "$COLUMNS" "")
  _padding_lenght=$((_column_width - ${#HOME}))
  _divider=${_padding// /=}

  if diff -q "$_home_dotfile" "$_backup_dotfile" >/dev/null 2>&1; then
    printf "\nBoth files are identical.\n"
  else
    printf "\nThe two files are different. See the diff of %s:\n\n" "$(highlight "$_filename")"
    printf "%s%0.${_padding_lenght}s%s\n" "$HOME" "$_padding" "$DOTIG_PATH"
    printf "%s\n" "$_divider"
    command diff --color -y --width="$COLUMNS" -t --suppress-common-lines "$_home_dotfile" "$_backup_dotfile" || [ $? -eq 1 ]
  fi
}

# Display the available choices in case of duplicate files.
print_duplicate_menu() {
  printf "[%s] Show diff\n" "$(option "1")"
  printf "[%s] Use %s (delete the other)\n" "$(option "2")" "$(highlight "$_home_dotfile")"
  printf "[%s] Use %s (delete the other)\n" "$(option "3")" "$(highlight "$_backup_dotfile")"
  printf "[%s] Skip this file\n" "$(option "4")"
}

# Execute the action specified by the user in case of duplication.
# Argument 1: the file residing in $HOME.
# Argument 2: the file residing in $DOTFILES.
handle_duplicate() {
  local _choice
  local _home_dotfile=$1
  local _backup_dotfile=$2

  if [ $_ignore_duplicate = "true" ]; then
    skipped "$_home_dotfile (duplicate)"
  else
    printf "\n"
    warning "A file with the same name already exists."

    [ -h "$_backup_dotfile" ] && warning "$(highlight "$_backup_dotfile") is a symlink."
    [ -h "$_home_dotfile" ] && warning "$(highlight "$_home_dotfile") is a symlink."

    printf "How do you want to proceed?\n"

    while true; do
      print_duplicate_menu
      printf "Your choice: "
      read -r _choice

      case $_choice in
      1)
        print_diff "$_home_dotfile" "$_backup_dotfile"
        printf "\n"
        ;;
      2)
        mv -f "$_home_dotfile" "$_backup_dotfile"
        ln -s "$_backup_dotfile" "$_home_dotfile"
        printf "\n"
        success "$(highlight "$_backup_dotfile") replaced with $(highlight "$_home_dotfile") and symlink created."
        break
        ;;
      3)
        rm "$_home_dotfile"
        ln -s "$_backup_dotfile" "$_home_dotfile"
        printf "\n"
        success "$(highlight "$_home_dotfile") replaced with a symlink."
        break
        ;;
      4)
        skipped "$_home_dotfile"
        break
        ;;
      *)
        printf "\n"
        error "Choose between $(option "1"), $(option "2"), $(option "3") or $(option "4")."
        ;;
      esac
    done
  fi
}

# Create and symlink the backup dotfile depending on the dotfile location.
# Argument 1: the dotfile
# Argument 2: the backup dotfile
create_backup_dotfile() {
  [ $# -ne 2 ] && error_unexpected

  local _dotfile=$1
  local _backup_dotfile=$2

  is_verbose && printf "Creating path if not already present...\n"
  mkdir -p "$(dirname "$_backup_dotfile")"

  if is_file_in "$_dotfile" "$HOME"; then
    is_verbose && printf "Moving %s to %s...\n" "$_dotfile" "$_backup_dotfile"
    mv "$_dotfile" "$_backup_dotfile"
    is_verbose && printf "Symlinking %s to %s...\n" "$_backup_dotfile" "$_dotfile"
    ln -s "$_backup_dotfile" "$_dotfile"
    success "$(highlight "$_dotfile") moved and symlink created."
  else
    is_verbose && printf "Copying %s to %s...\n" "$_dotfile" "$_backup_dotfile"
    cp "$_dotfile" "$_backup_dotfile"
    success "$(highlight "$_dotfile") copied."
    warning "Symlink not created. $(highlight "$_dotfile") is not in $HOME!"
  fi
}

# Move the dotfiles from $HOME to $DOTFILES and create a symlink.
# Accept 0 or more arguments. If arguments are provided, files are expected.
add_dotfiles() {
  local _dotfiles
  local _partial_dest
  local _removed_part
  local _backup_dotfile

  if [ $# -eq 0 ]; then
    printf "\nDotfiles to add: "
    read -r -e -a _dotfiles
  else
    _dotfiles=("$@")
  fi

  for _dotfile in "${_dotfiles[@]}"; do
    get_absolute_path _dotfile
    [ ! -e "$_dotfile" ] && error "$(highlight "$_dotfile") is not a file." && exit 2

    case $_dotfile in
    "$XDG_BIN_HOME"*)
      _partial_dest="home/xdg_bin"
      _removed_part="$XDG_BIN_HOME"
      ;;
    "$XDG_CACHE_HOME"*)
      _partial_dest="/home/xdg_cache"
      _removed_part="$XDG_CACHE_HOME"
      ;;
    "$XDG_CONFIG_HOME"*)
      _partial_dest="/home/xdg_config"
      _removed_part="$XDG_CONFIG_HOME"
      ;;
    "$XDG_DATA_HOME"*)
      _partial_dest="/home/xdg_data"
      _removed_part="$XDG_DATA_HOME"
      ;;
    "$XDG_LIB_HOME"*)
      _partial_dest="/home/xdg_lib"
      _removed_part="$XDG_LIB_HOME"
      ;;
    "$XDG_STATE_HOME"*)
      _partial_dest="/home/xdg_state"
      _removed_part="$XDG_STATE_HOME"
      ;;
    "$HOME"*)
      _partial_dest="/home"
      _removed_part="$HOME"
      ;;
    *)
      _partial_dest=""
      _removed_part=""
      ;;
    esac

    _backup_dotfile="${DOTIG_PATH}${_partial_dest}${_dotfile#$_removed_part}"

    if [ -e "$_backup_dotfile" ]; then
      handle_duplicate "$_dotfile" "$_backup_dotfile"
    else
      create_backup_dotfile "$_dotfile" "$_backup_dotfile"
    fi
  done

  return_menu
}

# Find all dotfiles in the backup path excluding submodules.
# Return a list of files.
get_backup_dotfiles() {
  local _find_cmd
  local _exclude_dirs=()
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_submodules_path >"$_tmp"

  while IFS='' read -r line; do _exclude_dirs+=("$line"); done <"$_tmp"

  rm "$_tmp"
  _exclude_dirs+=('.git')

  _find_cmd=(find "$DOTIG_PATH" -mindepth 2 \( -type f -o -type l \))

  for _exclude_dir in "${_exclude_dirs[@]}"; do
    _find_cmd+=(-not \( -path "$DOTIG_PATH${_exclude_dir}/*" -prune \))
  done
  _find_cmd+=(-print)

  "${_find_cmd[@]}"
}

# Handle existing symlink: check if the symlink target is the expected one or
# ask user which action to perform.
# Argument 1: the file (or symlink) residing in the backup path.
# Argument 2: the symlink residing in $HOME.
handle_target_update() {
  [ $# -ne 2 ] && error_unexpected

  local _file=$1
  local _file_target
  local _symlink=$2
  local _symlink_target
  local _extra_info
  local _choice

  _symlink_target=$(readlink -f "$_symlink") || true
  [ -z "$_symlink_target" ] && _symlink_target="Target does not exist."

  if [ "$_symlink_target" = "$_file" ]; then
    if is_verbose; then
      printf "A symlink with the same target already exists.\n"
      skipped "$_file"
    fi
  elif [ $_ignore_symlink_different_target = "true" ]; then
    skipped "$_file (different target)"
  else
    if [ -h "$_file" ]; then
      _extra_info=" (also a symlink)"
      _file_target=$(readlink -f "$_file") || true
      [ -z "$_file_target" ] && _file_target="Target does not exist."
    fi

    printf "\n"
    warning "A symlink exists but its target does not match your dotfile backup:"
    printf "* Symlink: %s\n" "$(highlight "$_symlink")"
    printf "* Symlink target: %s\n" "$(highlight "$_symlink_target")"
    printf "* Backup file%s: %s\n" "$_extra_info" "$(highlight "$_file")"
    [ -h "$_file" ] && printf "* Backup target: %s\n" "$(highlight "$_file_target")"

    while true; do
      printf "How do you want to proceed?\n"
      printf "[%s] Update the symlink\n" "$(option "1")"
      printf "[%s] Skip this file\n" "$(option "2")"
      printf "Your choice: "
      read -r _choice

      case $_choice in
      1)
        is_verbose && printf "Updating symlink target...\n"
        ln -s -f "$_file" "$_symlink"
        success "$(highlight "$_symlink") updated."
        break
        ;;
      2)
        printf "\n"
        skipped "$_file"
        break
        ;;
      *)
        printf "\n"
        error "Enter $(option "1") or $(option "2")."
        ;;
      esac
    done
  fi
}

# Find all broken symlinks in $HOME whose target is in $DOTFILES.
get_broken_symlinks() {
  find "$HOME" -type l -not \( -path "$DOTIG_PATH/*" -prune \) -ilname "$DOTIG_PATH*" ! -exec test -e {} \; -print
}

# Remove broken symlinks in $HOME whose target is in $DOTFILES.
remove_broken_symlinks() {
  local _tmp

  printf "\nChecking for broken symlinks...\n"

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_broken_symlinks >"$_tmp"

  if [ -s "$_tmp" ]; then
    while IFS= read -r file <&3; do
      rm "$file"
      is_verbose && success "$(highlight "$file") removed..."
    done 3<"$_tmp"

    success "All broken symlinks removed..."
  else
    printf "No broken symlinks found.\n"
  fi

  rm "$_tmp"
}

# Update symlink: create it if not already created or handle conflicts.
# Argument 1: the dotfile
# Argument 2: the backup dotfile
update_backup_symlink() {
  [ $# -ne 2 ] && error_unexpected

  local _dotfile=$1
  local _backup_dotfile=$2

  if is_file_in "$_dotfile" "$HOME"; then
    if [ -h "$_dotfile" ]; then
      handle_target_update "$_backup_dotfile" "$_dotfile"
    elif [ -f "$_dotfile" ]; then
      handle_duplicate "$_dotfile" "$_backup_dotfile"
    else
      is_verbose && printf "Creating symlink from %s to %s\n" "$_backup_dotfile" "$_dotfile"
      mkdir -p "$(dirname "$_dotfile")"
      ln -s "$_backup_dotfile" "$_dotfile"
      is_verbose && success "Symlink created for $(highlight "$_backup_dotfile")."
    fi
  else
    warning "$(highlight "$_dotfile") is not in $HOME. Symlink skipped."
  fi
}

# Create or update all symlinks in $HOME based on the dotfiles in the backup
# path and remove the broken symlinks.
update_symlinks() {
  local _backup_dotfile
  local _dotfile
  local _tmp

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  get_backup_dotfiles >"$_tmp"

  while IFS= read -r _backup_dotfile <&3; do
    case $_backup_dotfile in
    "${DOTIG_PATH}home/xdg_bin/"*)
      _partial_dest="$XDG_BIN_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_bin"
      ;;
    "${DOTIG_PATH}home/xdg_cache/"*)
      _partial_dest="$XDG_CACHE_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_cache"
      ;;
    "${DOTIG_PATH}home/xdg_config/"*)
      _partial_dest="$XDG_CONFIG_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_config"
      ;;
    "${DOTIG_PATH}home/xdg_data/"*)
      _partial_dest="$XDG_DATA_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_data"
      ;;
    "${DOTIG_PATH}home/xdg_lib/"*)
      _partial_dest="$XDG_LIB_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_lib"
      ;;
    "${DOTIG_PATH}home/xdg_state/"*)
      _partial_dest="$XDG_STATE_HOME"
      _removed_part="${DOTIG_PATH}home/xdg_state"
      ;;
    "${DOTIG_PATH}home/"*)
      _partial_dest="$HOME"
      _removed_part="${DOTIG_PATH}home"
      ;;
    *)
      _partial_dest=""
      _removed_part="$DOTIG_PATH"
      ;;
    esac

    _dotfile="${_partial_dest}${_backup_dotfile#$_removed_part}"

    update_backup_symlink "$_dotfile" "$_backup_dotfile"
  done 3<"$_tmp"

  rm "$_tmp"

  printf "\n"
  success "Done. Symlinks have been updated except those that have possibly been manually skipped or needing administrator rights."

  remove_broken_symlinks
  return_menu
}

# Replace the symlink with the backup file.
# Argument 1: the symlink.
# Argument 2: the backup file.
replace_symlink_with_file() {
  [ $# -ne 2 ] && error_unexpected

  local _symlink=$1
  local _backup_file=$2

  cp --remove-destination "$_backup_file" "$_symlink"
  if is_verbose; then
    success "$(highlight "$_symlink") replaced with $(highlight "$_backup_file")"
  fi
}

# Execute the action specified by the user if the symlink target does not match
# the backup file.
# Argument 1: the symlink.
# Argument 2: the symlink target.
# Argument 3: the backup file.
handle_target_issue() {
  [ $# -ne 3 ] && error_unexpected

  local _symlink=$1
  local _target=$2
  local _backup_file=$3

  printf "\n"
  warning "The symlink target does not match with your backup file:"
  printf "* Symlink: %s\n" "$(highlight "$_symlink")"
  printf "* Symlink target: %s\n" "$(highlight "$_target")"
  printf "* Backup file: %s\n" "$(highlight "$_backup_file")"

  printf "How do you want to proceed?\n"
  printf "[%s] Replace symlink with backup file\n" "$(option "1")"
  printf "[%s] Skip this symlink\n" "$(option "2")"

  while true; do
    printf "Your choice: "
    read -r _choice
    case $_choice in
    1)
      replace_symlink_with_file "$_symlink" "$_backup_file"
      break
      ;;
    2)
      is_verbose && printf "\n" && skipped "$_symlink"
      break
      ;;
    *)
      printf "\n"
      error "Enter $(option "1") or $(option "2")."
      ;;
    esac
  done
}

# Replace all symlinks in $HOME whose target is in $DOTFILES with the
# backup file.
remove_symlinks() {
  local _symlink
  local _symlink_target
  local _backup_dotfile
  local _tmp

  printf "\nReplacing symlinks with original files...\n"

  _tmp=$(mktemp "${TMPDIR:-/tmp}/dotig.XXXXXX")
  find "$HOME" -type l -not \( -path "$DOTIG_PATH/*" -prune \) -ilname "$DOTIG_PATH*" -print >"$_tmp"

  while IFS= read -r _symlink <&3; do
    _symlink_target=$(readlink "$_symlink") || true

    case $_symlink_target in
    "${DOTIG_PATH}home/xdg_bin/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_bin"
      _removed_part="$XDG_BIN_HOME"
      ;;
    "${DOTIG_PATH}home/xdg_cache/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_cache"
      _removed_part="$XDG_CACHE_HOME"
      ;;
    "${DOTIG_PATH}home/xdg_config/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_config"
      _removed_part="$XDG_CONFIG_HOME"
      ;;
    "${DOTIG_PATH}home/xdg_data/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_data"
      _removed_part="$XDG_DATA_HOME"
      ;;
    "${DOTIG_PATH}home/xdg_lib/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_lib"
      _removed_part="$XDG_LIB_HOME"
      ;;
    "${DOTIG_PATH}home/xdg_state/"*)
      _partial_dest="${DOTIG_PATH}home/xdg_state"
      _removed_part="$XDG_STATE_HOME"
      ;;
    "${DOTIG_PATH}home/"*)
      _partial_dest="${DOTIG_PATH}home"
      _removed_part="$HOME"
      ;;
    *)
      _partial_dest="$DOTIG_PATH"
      _removed_part=""
      ;;
    esac

    _backup_dotfile=${_partial_dest}${_symlink#$_removed_part}

    if [ "$_backup_dotfile" = "$_symlink_target" ]; then
      replace_symlink_with_file "$_symlink" "$_backup_dotfile"
    else
      handle_target_issue "$_symlink" "$_symlink_target" "$_backup_dotfile"
    fi

  done 3<"$_tmp"

  rm "$_tmp"

  printf "\n"
  success "Done. Symlinks have been replaced except those that have possibly been manually skipped."

  return_menu
}

###############################################################################
# 5.2. Feature: Git
# Handle commit, push and pull from Dotig.
###############################################################################

# Commit all changes in the $DOTFILES repository.
commit_changes() {
  [ $# -gt 1 ] && invalid_usage

  local _staged_files

  if [ "$_commit_files" = "untracked" ]; then
    if [ "$(get_untracked_files_count)" -gt 0 ]; then
      git -C "$DOTIG_PATH" add "$(git -C "$DOTIG_PATH" ls-files -o --exclude-standard)"
    else
      printf "\nThere are no untracked files.\n"
    fi
  elif [ "$_commit_files" = "tracked" ]; then
    if [ "$(get_modified_files_count)" -gt 0 ] || [ "$(get_deleted_files_count)" -gt 0 ]; then
      git -C "$DOTIG_PATH" add -u
    else
      printf "\nThere are no modified or deleted files.\n"
    fi
  else
    git -C "$DOTIG_PATH" add --all
  fi

  _staged_files=$(get_staged_files_count) || true

  if [ "$_staged_files" -ne 0 ]; then
    printf "\n"
    if [ $# -eq 0 ]; then
      git -C "$DOTIG_PATH" commit
    else
      local _commit_msg=$1
      if [ -n "$_commit_msg" ]; then
        git -C "$DOTIG_PATH" commit -m "$_commit_msg"
      else
        invalid_usage "commit"
      fi
    fi
    success "Changes committed!"
  else
    printf "\nCommit is not necessary, no staged files.\n"
  fi

  return_menu
}

# Push all unpushed commits in $DOTFILES repository.
push_changes() {
  local _unpushed_commits_count
  _unpushed_commits_count=$(get_unpushed_commits | wc -l)

  if [ "$_unpushed_commits_count" -ne 0 ]; then
    git -C "$DOTIG_PATH" push
    printf "\n"
    success "Commit(s) pushed!"
  else
    printf "\nNothing to push.\n"
  fi

  return_menu
}

# Pull changes from remote repository.
pull_changes() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if ! is_repo_up_to_date "$_local_commit" "$_remote_commit" && is_pull_needed "$_local_commit" "$_common_ancestor"; then
    if ! is_repo_dirty; then
      git -C "$DOTIG_PATH" pull --rebase
      printf "\n"
      success "Repo is now up-to-date!"
    else
      printf "\n"
      warning "Dotig cannot pull. Your repo is dirty."
      printf "See the details below.\n"
      print_dirty_summary
      printf "Commit or stash (manually) your changes if you want to pull.\n"
    fi
  else
    printf "\nNothing to pull.\n"
  fi

  return_menu
}

# Update all Git submodules.
update_all_submodules() {
  is_verbose && printf "\nChecking for Git submodules...\n"
  if has_submodules; then
    is_verbose && printf "Updating Git submodules..."
    update_submodules
    printf "\n"
    success "All submodules have been updated."
  else
    printf "No submodules found.\n"
  fi

  return_menu
}

###############################################################################
# 5.3. Feature: Repo Status
# Call git to obtain some info about the repo status and display these info.
###############################################################################

# Display the number of affected files foreach type of change.
print_dirty_summary() {
  local _untracked_files_count
  local _staged_files_count
  local _deleted_files_count
  local _renamed_files_count
  local _modified_files_count
  local _unmerged_files_count
  local _stashed_files_count
  local _expanded_status

  _untracked_files_count=$(get_untracked_files_count) || true
  _staged_files_count=$(get_staged_files_count) || true
  _deleted_files_count=$(get_deleted_files_count) || true
  _renamed_files_count=$(get_renamed_files_count) || true
  _modified_files_count=$(get_modified_files_count) || true
  _unmerged_files_count=$(get_unmerged_files_count) || true
  _stashed_files_count=$(get_stashed_count) || true

  _expanded_status="You have:\n"
  [ "$_untracked_files_count" -gt 0 ] && _expanded_status+="* $_untracked_files_count untracked files\n"
  [ "$_staged_files_count" -gt 0 ] && _expanded_status+="* $_staged_files_count staged files\n"
  [ "$_deleted_files_count" -gt 0 ] && _expanded_status+="* $_deleted_files_count deleted files\n"
  [ "$_renamed_files_count" -gt 0 ] && _expanded_status+="* $_renamed_files_count renamed files"
  [ "$_modified_files_count" -gt 0 ] && _expanded_status+="* $_modified_files_count modified files\n"
  [ "$_unmerged_files_count" -gt 0 ] && _expanded_status+="* $_unmerged_files_count unmerged files\n"
  [ "$_stashed_files_count" -gt 0 ] && _expanded_status+="* $_stashed_files_count stashed files\n"

  printf "%b" "$_expanded_status"
}

print_dirty_expanded() {
  if is_repo_dirty; then
    if [ "$(get_modified_files_count)" -ge 1 ]; then
      printf "\n%s modified files:\n" "$(get_modified_files_count)"
      git -C "$DOTIG_PATH" ls-files -m
    fi
    if [ "$(get_untracked_files_count)" -ge 1 ]; then
      printf "\n%s untracked files:\n" "$(get_untracked_files_count)"
      git -C "$DOTIG_PATH" ls-files -o
    fi
    if [ "$(get_deleted_files_count)" -ge 1 ]; then
      printf "\n%s deleted files:\n" "$(get_deleted_files_count)"
      git -C "$DOTIG_PATH" ls-files -d
    fi
    if [ "$(get_renamed_files_count)" -ge 1 ]; then
      printf "\n%s renamed files.\n" "$(get_renamed_files_count)"
    fi
    if [ "$(get_unmerged_files_count)" -ge 1 ]; then
      printf "\n%s unmerged files:\n" "$(get_unmerged_files_count)"
      git -C "$DOTIG_PATH" ls-files -u
    fi
    if [ "$(get_stashed_count)" -ge 1 ]; then
      printf "\n%s stashed files:\n" "$(get_stashed_count)"
      git -C "$DOTIG_PATH" stash list
    fi
    if [ "$(get_staged_files_count)" -ge 1 ]; then
      printf "\n%s staged files:\n" "$(get_staged_files_count)"
      git -C "$DOTIG_PATH" diff --name-only --cached
    fi
  else
    printf "\nYou do not have any dirty files.\n"
  fi

  return_menu
}

# Display the repository status.
get_repo_status() {
  local _local_commit
  local _remote_commit
  local _common_ancestor

  printf "\nChecking status...\n"
  printf "Your SSH passphrase can be requested.\n"
  fetch_remote

  _local_commit=$(get_local_commit) || true
  _remote_commit=$(get_remote_commit) || true
  _common_ancestor=$(get_common_ancestor "$_local_commit" "$_remote_commit") || true

  if is_repo_up_to_date "$_local_commit" "$_remote_commit"; then
    status -s "up-to-date!"
  else
    is_pull_needed "$_local_commit" "$_common_ancestor" && status -w "pull needed!"
    is_push_needed "$_remote_commit" "$_common_ancestor" && status -w "push needed!"
  fi

  if is_repo_dirty; then
    status -w "dirty repo!"
    if [ $_show_dirty_filenames = "true" ]; then
      print_dirty_expanded
    else
      print_dirty_summary
    fi
  else
    status -s "clean repo!"
  fi
}

###############################################################################
# 5.4. Feature: Dotig Info
# Allow user to check current version of Dotig and to check for updates.
###############################################################################

# Display the version number of Dotig.
print_dotig_version() {
  printf "\nYour Dotig version is: %s\n" "$DOTIG_VERSION"
  return_menu
}

# Get a JSON object corresponding to the latest release.
get_latest_release() {
  curl -s -H "Accept: application/vnd.github.v3+json" https://api.github.com/repos/ArmandPhilippot/dotig/releases/latest
}

# Check if a new release exist by comparing the current version and the version
# of the latest release. If a new version exists, display a link to download it.
check_dotig_updates() {
  local _latest_release
  local _tag_name
  local _new_version
  local _download_zip
  local _download_link
  local _not_found

  if ! is_curl_installed; then
    printf "\n"
    error "curl is needed to check for Dotig update. Please install it."
    return_menu
  fi

  _latest_release=$(get_latest_release)
  _not_found=$(printf "%s" "$_latest_release" | { grep -Po '"message": "Not Found"' || true; })

  [ "$_not_found" ] && printf "\n" && error "Could not find any release..." && return_menu

  _tag_name=$(printf "%s" "$_latest_release" | grep -Po '"tag_name":.*?[^\\]",')
  _new_version=$(printf "%s" "$_tag_name" | grep -Po '(?=v).*(?=",)' | sed 's/^v//')

  if [ "$_new_version" = "$DOTIG_VERSION" ]; then
    printf "\n"
    success "Your Dotig version is up to date!"
  else
    _download_zip=$(printf "%s" "$_latest_release" | grep -Po '"zipball_url":.*?[^\\]",')
    _download_link=$(printf "%s" "$_download_zip" | grep -Po 'http.*(?=",)')

    printf "\n"
    warning "Your Dotig version is outdated!"
    printf "A new version is available: %s\n" "$_new_version"
    printf "You can download it here: %s\n" "$_download_link"
  fi

  return_menu
}

###############################################################################
# 6. Help Menus
# Functions to print the various help menus.
###############################################################################

# Display the main help menu.
print_dotig_help() {
  cat <<EOF
# USAGE
dotig [OPTIONS]
dotig <COMMANDS> [OPTIONS] [<FILES...>]

# DESCRIPTION
Dotig is a dotfiles manager to quickly setup your machine & synchronize your dotfiles with Git.

# COMMANDS
add                 Add new dotfiles and create symlinks.
                    Accept both absolute and relative paths.
update              Update all symlinks.
commit              Use Git to commit all changes.
push                Use Git to push all changes.
pull                Use Git to pull changes from remote.
submodule           Update Git submodules.
rm                  Replace all symlinks with the original file.
                    The original will be conserved in your repository.
status              Display the status of your dotfiles repository.
                    Check for dirty files and if push or pull is needed.

# OPTIONS
-h, --help          Print this help. If used after a command, you can print help
                    for this command.
-ns, --no-status    Do not show the repo status.
-p, --private       Use your private dotfiles repository instead of the default.
-v, --verbose       Explain what is done.
--version           Print Dotig version and check for new releases.

# CONFIGURATION
DOTFILES            Environment variable to define the path of your dotfiles
                    repository.
                    Current value: $DOTFILES
DOTFILES_PRIVATE    Environment variable to define the path of your private
                    dotfiles repository.
                    Current value: $DOTFILES_PRIVATE

You need to declare these values in your shell configuration files. For example in .profile for Bash or .zshenv for Zsh.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version             Dotig $DOTIG_VERSION
License             MIT
Project URL         https://github.com/ArmandPhilippot/dotig
EOF

  return_menu
}

# Display the help for add command then exit.
print_add_help() {
  cat <<EOF
# USAGE
dotig add [OPTIONS] [<FILES...>]

# DESCRIPTION
The add command allows Dotig to copy your dotfiles inside your backup directory then to symlink them. You can provide one or more files. If it is a directory, the files inside will be processed.

# OPTIONS
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for update command then exit.
print_update_help() {
  cat <<EOF
# USAGE
dotig update [OPTIONS]

# DESCRIPTION
The update command allows Dotig to create or update all the symlinks based on your backup dotfiles. This command also removes all the broken symlinks in your \$HOME if the symlink target is in your repo.
It only handles files in home directory. If your repo contains files outside your \$HOME you need to create the symlinks yourself.

# OPTIONS
-h, --help                Print this help.
-ia, --ignore-all         Always skip files when a conflict exists. You can
                          achieve the same thing by combining --ignore-duplicate
                          and --ignore-target.
-id, --ignore-duplicate   Always skip symlinking when a file with the same name
                          already exists.
-it, --ignore-target      Always skip symlinking when a symlink already exists
                          even if the target is not the same.
-p, --private             Use your private dotfiles repository instead of the
                          default.
-v, --verbose             Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for commit command then exit.
print_commit_help() {
  cat <<EOF
# USAGE
dotig commit [OPTIONS]

# DESCRIPTION
The commit command allows Dotig to staged all changes in your repository (untracked, modified, renamed files for example) then to call the Git commit command. Then, you will be able to enter a commit message.

# OPTIONS
-h, --help        Print this help.
-m, --message     Use the given string as commit message. If used with another
                  option, the message must follow the -m or --message option.
-p, --private     Use your private dotfiles repository instead of the default.
-t, --tracked     Commit only tracked files. Ignore untracked.
-u, --untracked   Commit only untracked files. Ignore others (i.e. modified or
                  deleted).
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for push command then exit.
print_push_help() {
  cat <<EOF
# USAGE
dotig push [OPTIONS]

# DESCRIPTION
The push command allows Dotig to push all the commits to your remote repository. If Dotig cannot find new commits, it will print that push is not necessary.

# OPTIONS
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for pull command then exit.
print_pull_help() {
  cat <<EOF
# USAGE
dotig pull [OPTIONS]

# DESCRIPTION
The pull command allows Dotig to fetch your remote repository then to merge all incoming changes inside your local repository using the Git rebase strategy. If Dotig cannot find new remote changes, it will print that pull is not necessary.

# OPTIONS
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for submodule command then exit.
print_submodule_help() {
  cat <<EOF
# USAGE
dotig submodule [OPTIONS]

# DESCRIPTION
If you are using git submodules inside your dotfiles repository, the submodule command allows Dotig to update all of them.

# OPTIONS
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for remove command then exit.
print_remove_help() {
  cat <<EOF
# USAGE
dotig rm [OPTIONS]

# DESCRIPTION
The rm command allows Dotig to replace all the symlinks in your \$HOME whose target is in your repository with the original file. The file insde your repository will be kept.

# OPTIONS
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

# Display the help for status command then exit.
print_status_help() {
  cat <<EOF
# USAGE
dotig status [OPTIONS]

# DESCRIPTION
The status command allows Dotig to display information about your repository status. It will check if your repository is up to date and clean.
This command will tell you if you need to pull or push changes. If your repository is dirty it will also print some information to help you know why by displaying the number of modified, staged, removed or untracked files.

# OPTIONS
-e, --expanded    If your local repository is dirty, print the concerned files
                  by category (i.e. modified files, deleted files...).
-h, --help        Print this help.
-p, --private     Use your private dotfiles repository instead of the default.
-v, --verbose     Explain what is done.

# BUGS
If you find any bug, you can report it on https://github.com/ArmandPhilippot/dotig/issues.

# ABOUT
Version           Dotig $DOTIG_VERSION
License           MIT
Project URL       https://github.com/ArmandPhilippot/dotig
EOF

  exit
}

###############################################################################
# 7. Main Menu
# Display all possible options.
###############################################################################

# Display the list of choices available in the main menu of Dotig.
print_menu_options() {
  printf "\nChoose an action to perform:\n"
  printf "[%s] Add dotfile(s) to your repo\n" "$(option "1")"
  printf "[%s] Update symlinks\n" "$(option "2")"
  printf "[%s] Commit dotfiles changes\n" "$(option "3")"
  printf "[%s] Push changes to remote\n" "$(option "4")"
  printf "[%s] Pull changes from remote\n" "$(option "5")"
  printf "[%s] Update all Git submodules\n" "$(option "6")"
  printf "[%s] Remove all symlinks\n" "$(option "7")"
  printf "[%s] Print the dirty files list\n" "$(option "8")"
  printf "[%s] Check for Dotig update\n" "$(option "9")"
  printf "[%s] Print Dotig version\n" "$(option "10")"
  printf "[%s] Print Dotig help\n" "$(option "11")"
  printf "[%s] Exit\n" "$(option "q")"
}

# Display the main menu of Dotig.
print_menu() {
  local _choice

  while true; do
    print_menu_options
    printf "Your choice: "
    read -r _choice

    case $_choice in
    1) add_dotfiles ;;
    2) update_symlinks ;;
    3) commit_changes ;;
    4) push_changes ;;
    5) pull_changes ;;
    6) update_all_submodules ;;
    7) remove_symlinks ;;
    8) print_dirty_expanded ;;
    9) check_dotig_updates ;;
    10) print_dotig_version ;;
    11) print_dotig_help ;;
    [qQ]) exit ;;
    *) error "Invalid choice. Try again." ;;
    esac
  done
}

# Ask user if he wants to return to the menu or exit Dotig.
return_menu() {
  [ $_disable_menu = "true" ] && return

  local _choice

  while true; do
    printf "\nWhat do you want to do: return to the menu [%s] or exit [%s]? " "$(option "r")" "$(option "e")"
    read -r _choice

    case $_choice in
    [rR]) return ;;
    [qQ]) exit ;;
    *)
      printf "\n"
      error "Invalid choice. Please enter $(option "r") (return) or $(option "e") (exit)."
      ;;
    esac
  done
}

###############################################################################
# 8. Entry Point
# Main entry point of Dotig.
###############################################################################

main() {
  print_logo
  check_requirements
  is_backup_repo_ready
  set_xdg_paths
  [ $_show_repo_status = "true" ] && get_repo_status
  print_menu
}

###############################################################################
# 9. CLI
# Handle the command line interface scenario.
###############################################################################

# Handle options for the add dotfiles command before calling it.
call_add_dotfiles() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "add"
    print_add_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) break ;;
      esac
    done

    add_dotfiles "$@"
  fi
}

# Handle options for the update symlinks command before calling it.
call_update_symlinks() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "update"
    print_update_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --ignore-all | -ia)
        _ignore_duplicate="true"
        _ignore_symlink_different_target="true"
        shift
        ;;
      --ignore-duplicate | -id)
        _ignore_duplicate="true"
        shift
        ;;
      --ignore-target | -it)
        _ignore_symlink_different_target="true"
        shift
        ;;
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "update" ;;
      esac
    done

    update_symlinks
  fi
}

# Handle options for the commit changes command before calling it.
call_commit_changes() {
  local _commit_message

  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "commit"
    print_commit_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --message | -m)
        shift
        _commit_message="$1"
        shift
        ;;
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --tracked | -t)
        _commit_files="tracked"
        shift
        ;;
      --untracked | -u)
        _commit_files="untracked"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "commit" ;;
      esac
    done

    if [ -n "$_commit_message" ]; then
      commit_changes "$_commit_message"
    else
      commit_changes
    fi
  fi
}

# Handle options for the push changes command before calling it.
call_push_changes() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "push"
    print_push_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "push" ;;
      esac
    done

    push_changes
  fi
}

# Handle options for the pull changes command before calling it.
call_pull_changes() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "pull"
    print_pull_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "pull" ;;
      esac
    done

    pull_changes
  fi
}

# Handle options for the update submodules command before calling it.
call_update_all_submodules() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "submodule"
    print_submodule_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "submodule" ;;
      esac
    done

    update_all_submodules
  fi
}

# Handle options for the remove symlinks command before calling it.
call_remove_symlinks() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "rm"
    print_remove_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "rm" ;;
      esac
    done

    remove_symlinks
  fi
}

# Handle options for the get repo status command before calling it.
call_get_repo_status() {
  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage "status"
    print_status_help
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --expanded | -e)
        _show_dirty_filenames="true"
        shift
        ;;
      --private | -p)
        _private_dotfiles="true"
        set_dotig_path "$DOTFILES_PRIVATE"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *) invalid_usage "status" ;;
      esac
    done

    get_repo_status
  fi
}

# Redirect command to the right function.
# Require 1 or more arguments.
# Argument 1: a valid command.
handle_dotig_cli_commands() {
  if [ "$_private_dotfiles" = "true" ]; then
    set_dotig_path "$DOTFILES_PRIVATE"
  else
    set_dotig_path "$DOTFILES"
  fi

  _disable_menu="true"

  set_xdg_paths

  local _command_name=$1
  shift

  case $_command_name in
  add) call_add_dotfiles "$@" ;;
  update) call_update_symlinks "$@" ;;
  commit) call_commit_changes "$@" ;;
  push) call_push_changes "$@" ;;
  pull) call_pull_changes "$@" ;;
  submodule) call_update_all_submodules "$@" ;;
  rm) call_remove_symlinks "$@" ;;
  status) call_get_repo_status "$@" ;;
  *) error_unexpected ;;
  esac

  exit
}

# Set Dotig options according to the arguments passed through CLI
# Require at least one argument.
# Additional arguments are valid in some cases.
set_dotig_options() {
  [ $# -eq 0 ] && error_unexpected

  if is_command_help "$1"; then
    [ $# -gt 1 ] && invalid_usage
    _disable_menu="true"
    print_dotig_help
    exit
  elif [ "$1" = "--version" ]; then
    [ $# -gt 1 ] && invalid_usage
    _disable_menu="true"
    print_dotig_version
    check_dotig_updates
    exit
  else
    while [ $# -ge 1 ]; do
      case $1 in
      --no-status | -ns)
        _show_repo_status="false"
        shift
        ;;
      --private | -p)
        _private_dotfiles="true"
        shift
        ;;
      --verbose | -v)
        _verbose="true"
        shift
        ;;
      *)
        if is_dotig_cli_command "$1"; then
          handle_dotig_cli_commands "$@"
        else
          invalid_usage
        fi
        ;;
      esac
    done

    main
  fi
}

# Handle Dotig CLI.
# Require 1 or more arguments.
dotig_cli() {
  if is_dotig_cli_command "$1"; then
    handle_dotig_cli_commands "$@"
  else
    set_dotig_options "$@"
  fi
}

###############################################################################
# 10. Execute Dotig
###############################################################################

if [ $# -eq 0 ]; then
  main
else
  dotig_cli "$@"
fi
